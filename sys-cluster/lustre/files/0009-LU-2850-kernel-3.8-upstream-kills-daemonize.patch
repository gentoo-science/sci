From f5d1ce5309c4bb7b39f6e49970a3d0e0a4e8a40e Mon Sep 17 00:00:00 2001
From: Peng Tao <tao.peng@emc.com>
Date: Mon, 18 Mar 2013 10:47:57 +0800
Subject: [PATCH 09/12] LU-2850 kernel: 3.8 upstream kills daemonize()

kernel_thread() is a low level kernel function.
Instead of calling kernel_thread() and relying on daemonize()
to create new kernel threads, we should really switch to
kthread_run() and elimilate daemonize().

Conflicts:
	libcfs/autoconf/lustre-libcfs.m4
	lustre/mdd/mdd_lfsck.c
	lustre/obdclass/llog_cat.c
	lustre/ptlrpc/recov_thread.c

Signed-off-by: Peng Tao <tao.peng@emc.com>
Change-Id: I9f977bfc5d58192957d8c8d634204f4910edfa2a
---
 libcfs/autoconf/lustre-libcfs.m4           | 19 -------
 libcfs/include/libcfs/darwin/darwin-prim.h |  6 +--
 libcfs/include/libcfs/libcfs.h             | 13 +----
 libcfs/include/libcfs/linux/linux-prim.h   |  9 ----
 libcfs/include/libcfs/posix/libcfs.h       |  1 +
 libcfs/include/libcfs/user-prim.h          |  5 +-
 libcfs/include/libcfs/winnt/winnt-prim.h   |  4 --
 libcfs/libcfs/Makefile.in                  |  4 +-
 libcfs/libcfs/darwin/darwin-prim.c         | 39 +++++++-------
 libcfs/libcfs/darwin/darwin-utils.c        |  2 +-
 libcfs/libcfs/debug.c                      | 20 ++++----
 libcfs/libcfs/linux/Makefile.am            |  2 +-
 libcfs/libcfs/linux/linux-lwt.c            | 81 ------------------------------
 libcfs/libcfs/linux/linux-prim.c           | 40 +++++----------
 libcfs/libcfs/tracefile.c                  | 15 +++---
 libcfs/libcfs/user-prim.c                  | 38 +++++++-------
 libcfs/libcfs/watchdog.c                   | 25 ++++-----
 libcfs/libcfs/winnt/winnt-prim.c           | 27 ++++------
 libcfs/libcfs/winnt/winnt-tcpip.c          |  8 +--
 libcfs/libcfs/workitem.c                   | 26 +++++-----
 lnet/klnds/gnilnd/gnilnd_cb.c              |  4 --
 lnet/klnds/gnilnd/gnilnd_conn.c            |  6 ---
 lnet/klnds/gnilnd/gnilnd_stack.c           |  1 -
 lnet/klnds/mxlnd/mxlnd.c                   | 34 ++++++++-----
 lnet/klnds/mxlnd/mxlnd_cb.c                | 11 ----
 lnet/klnds/o2iblnd/o2iblnd.c               | 13 +++--
 lnet/klnds/o2iblnd/o2iblnd.h               |  2 +-
 lnet/klnds/o2iblnd/o2iblnd_cb.c            | 23 +++------
 lnet/klnds/ptllnd/ptllnd.c                 |  5 +-
 lnet/klnds/ptllnd/ptllnd_cb.c              | 25 ++++-----
 lnet/klnds/qswlnd/qswlnd.c                 |  3 +-
 lnet/klnds/qswlnd/qswlnd_cb.c              | 13 +++--
 lnet/klnds/ralnd/ralnd.c                   | 10 ++--
 lnet/klnds/ralnd/ralnd.h                   |  2 +-
 lnet/klnds/ralnd/ralnd_cb.c                | 19 ++-----
 lnet/klnds/socklnd/socklnd.c               | 19 +++++--
 lnet/klnds/socklnd/socklnd.h               |  2 +-
 lnet/klnds/socklnd/socklnd_cb.c            | 30 ++++-------
 lnet/lnet/acceptor.c                       | 11 ++--
 lnet/lnet/module.c                         | 10 ++--
 lnet/lnet/router.c                         | 20 ++++----
 lnet/selftest/timer.c                      | 11 ++--
 lnet/ulnds/socklnd/usocklnd.c              | 17 ++++---
 lustre/ldlm/ldlm_lib.c                     | 31 +++++-------
 lustre/ldlm/ldlm_lockd.c                   | 41 +++++++--------
 lustre/ldlm/ldlm_pool.c                    | 53 +++++++++----------
 lustre/llite/llite_capa.c                  | 25 +++++----
 lustre/llite/llite_close.c                 | 26 ++++------
 lustre/llite/lloop.c                       | 10 ++--
 lustre/llite/statahead.c                   | 61 +++++++++++-----------
 lustre/mdc/mdc_request.c                   | 34 ++++++-------
 lustre/mdd/mdd_lfsck.c                     |  7 ++-
 lustre/mdt/mdt_capa.c                      | 26 +++++-----
 lustre/mgc/mgc_request.c                   | 31 ++++++------
 lustre/mgs/mgs_nids.c                      | 13 ++---
 lustre/obdclass/genops.c                   | 22 +++-----
 lustre/obdclass/llog.c                     |  8 +--
 lustre/osd-ldiskfs/osd_scrub.c             |  5 +-
 lustre/osp/osp_precreate.c                 | 15 +++---
 lustre/osp/osp_sync.c                      |  9 ++--
 lustre/ptlrpc/import.c                     | 34 +++++++------
 lustre/ptlrpc/pinger.c                     | 39 +++++++-------
 lustre/ptlrpc/ptlrpcd.c                    | 25 +++++----
 lustre/ptlrpc/sec_gc.c                     | 12 ++---
 lustre/ptlrpc/service.c                    | 19 ++++---
 lustre/quota/qmt_lock.c                    | 17 +++----
 lustre/quota/qsd_reint.c                   |  6 +--
 lustre/quota/qsd_writeback.c               | 16 +++---
 68 files changed, 515 insertions(+), 745 deletions(-)
 delete mode 100644 libcfs/libcfs/linux/linux-lwt.c

diff --git a/libcfs/autoconf/lustre-libcfs.m4 b/libcfs/autoconf/lustre-libcfs.m4
index 4545a7a..03a428c 100644
--- a/libcfs/autoconf/lustre-libcfs.m4
+++ b/libcfs/autoconf/lustre-libcfs.m4
@@ -696,23 +696,6 @@ LB_LINUX_TRY_COMPILE([
 ])
 ])
 
-# 2.6.18 store oom parameters in task struct.
-# 2.6.32 store oom parameters in signal struct
-AC_DEFUN([LIBCFS_OOMADJ_IN_SIG],
-[AC_MSG_CHECKING([kernel store oom parameters in task])
-LB_LINUX_TRY_COMPILE([
-        #include <linux/sched.h>
-],[
-        ((struct signal_struct *)0)->oom_adj = 0;
-],[
-        AC_MSG_RESULT(yes)
-        AC_DEFINE(HAVE_OOMADJ_IN_SIG, 1,
-                  [kernel store a oom parameters in signal struct])
-],[
-        AC_MSG_RESULT(no)
-])
-])
-
 #
 # 2.6.33 no longer has ctl_name & strategy field in struct ctl_table.
 #
@@ -865,8 +848,6 @@ LIBCFS_HAVE_SET_MEMS_ALLOWED
 # 2.6.32
 LIBCFS_STACKTRACE_OPS_HAVE_WALK_STACK
 LC_SHRINKER_WANT_SHRINK_PTR
-LIBCFS_HAVE_OOM_H
-LIBCFS_OOMADJ_IN_SIG
 # 2.6.33
 LIBCFS_SYSCTL_CTLNAME
 # 2.6.34
diff --git a/libcfs/include/libcfs/darwin/darwin-prim.h b/libcfs/include/libcfs/darwin/darwin-prim.h
index 7bc7af3..583e257 100644
--- a/libcfs/include/libcfs/darwin/darwin-prim.h
+++ b/libcfs/include/libcfs/darwin/darwin-prim.h
@@ -202,10 +202,8 @@ extern task_t	kernel_task;
 
 #define CLONE_SIGNAL    (CLONE_SIGHAND | CLONE_THREAD)
 
-#define CFS_DAEMON_FLAGS (CLONE_VM | CLONE_FILES)
-
-extern int cfs_create_thread(cfs_thread_t func, void *arg, unsigned long flag);
-
+extern cfs_task_t kthread_run(cfs_thread_t func, void *arg,
+			      const char namefmt[], ...);
 
 /*
  * Wait Queue implementation
diff --git a/libcfs/include/libcfs/libcfs.h b/libcfs/include/libcfs/libcfs.h
index 2375ed9..34c36a3 100644
--- a/libcfs/include/libcfs/libcfs.h
+++ b/libcfs/include/libcfs/libcfs.h
@@ -226,8 +226,7 @@ void cfs_enter_debugger(void);
 /*
  * Defined by platform
  */
-void cfs_daemonize(char *str);
-int cfs_daemonize_ctxt(char *str);
+int unshare_fs_struct(void);
 cfs_sigset_t cfs_get_blocked_sigs(void);
 cfs_sigset_t cfs_block_allsigs(void);
 cfs_sigset_t cfs_block_sigs(unsigned long sigs);
@@ -236,16 +235,6 @@ void cfs_restore_sigs(cfs_sigset_t);
 int cfs_signal_pending(void);
 void cfs_clear_sigpending(void);
 
-/*
- * XXX Liang:
- * these macros should be removed in the future,
- * we keep them just for keeping libcfs compatible
- * with other branches.
- */
-#define libcfs_daemonize(s)     cfs_daemonize(s)
-#define cfs_sigmask_lock(f)     do { f= 0; } while (0)
-#define cfs_sigmask_unlock(f)   do { f= 0; } while (0)
-
 int convert_server_error(__u64 ecode);
 int convert_client_oflag(int cflag, int *result);
 
diff --git a/libcfs/include/libcfs/linux/linux-prim.h b/libcfs/include/libcfs/linux/linux-prim.h
index 1aeb5aa..31298e1 100644
--- a/libcfs/include/libcfs/linux/linux-prim.h
+++ b/libcfs/include/libcfs/linux/linux-prim.h
@@ -183,15 +183,6 @@ typedef long                            cfs_task_state_t;
 
 #define CFS_DECL_WAITQ(wq)		DECLARE_WAIT_QUEUE_HEAD(wq)
 
-#define cfs_kthread_run(fn, data, fmt, arg...) kthread_run(fn, data, fmt, ##arg)
-
-/* Kernel thread */
-typedef int (*cfs_thread_t)(void *);
-
-#define CFS_DAEMON_FLAGS (CLONE_VM | CLONE_FILES)
-extern int cfs_create_thread(int (*fn)(void *),
-                             void *arg, unsigned long flags);
-
 /*
  * Task struct
  */
diff --git a/libcfs/include/libcfs/posix/libcfs.h b/libcfs/include/libcfs/posix/libcfs.h
index 91158bc..c21e2e6 100644
--- a/libcfs/include/libcfs/posix/libcfs.h
+++ b/libcfs/include/libcfs/posix/libcfs.h
@@ -110,6 +110,7 @@
 typedef unsigned long long cfs_cycles_t;
 
 #define IS_ERR(a) ((unsigned long)(a) > (unsigned long)-1000L)
+#define IS_ERR_VALUE(a) (IS_ERR(a))
 #define PTR_ERR(a) ((long)(a))
 #define ERR_PTR(a) ((void*)((long)(a)))
 
diff --git a/libcfs/include/libcfs/user-prim.h b/libcfs/include/libcfs/user-prim.h
index 85253d8..c4e806c 100644
--- a/libcfs/include/libcfs/user-prim.h
+++ b/libcfs/include/libcfs/user-prim.h
@@ -157,9 +157,10 @@ static inline int cfs_psdev_deregister(cfs_psdev_t *foo)
 
 #ifdef HAVE_LIBPTHREAD
 typedef int (*cfs_thread_t)(void *);
-int cfs_create_thread(cfs_thread_t func, void *arg, unsigned long flags);
+void *kthread_run(cfs_thread_t func, void *arg, const char namefmt[], ...);
 #else
-#define cfs_create_thread(l,m) LBUG()
+/* Fine, crash, but stop giving me compile warnings */
+#define kthread_run(f, a, n, ...) LBUG()
 #endif
 
 uid_t cfs_curproc_uid(void);
diff --git a/libcfs/include/libcfs/winnt/winnt-prim.h b/libcfs/include/libcfs/winnt/winnt-prim.h
index 985af01..e234bba 100644
--- a/libcfs/include/libcfs/winnt/winnt-prim.h
+++ b/libcfs/include/libcfs/winnt/winnt-prim.h
@@ -442,8 +442,6 @@ typedef struct _cfs_thread_context {
     void *              arg;
 } cfs_thread_context_t;
 
-int cfs_create_thread(int (*func)(void *), void *arg, unsigned long flag);
-
 /*
  * thread creation flags from Linux, not used in winnt
  */
@@ -461,8 +459,6 @@ int cfs_create_thread(int (*func)(void *), void *arg, unsigned long flag);
 
 #define CLONE_SIGNAL    (CLONE_SIGHAND | CLONE_THREAD)
 
-#define CFS_DAEMON_FLAGS (CLONE_VM|CLONE_FILES)
-
 /*
  * group_info: linux/sched.h
  */
diff --git a/libcfs/libcfs/Makefile.in b/libcfs/libcfs/Makefile.in
index 71852cc..ddfadde 100644
--- a/libcfs/libcfs/Makefile.in
+++ b/libcfs/libcfs/Makefile.in
@@ -3,7 +3,7 @@ MODULES = libcfs
 libcfs-linux-objs := linux-tracefile.o linux-debug.o
 libcfs-linux-objs += linux-prim.o linux-mem.o linux-cpu.o
 libcfs-linux-objs += linux-fs.o linux-sync.o linux-tcpip.o
-libcfs-linux-objs += linux-lwt.o linux-proc.o linux-curproc.o
+libcfs-linux-objs += linux-proc.o linux-curproc.o
 libcfs-linux-objs += linux-utils.o linux-module.o
 libcfs-linux-objs += linux-crypto.o linux-crypto-crc32.o
 libcfs-linux-objs += linux-crypto-adler.o
@@ -29,7 +29,7 @@ sources:
 
 libcfs-linux-objs := $(addprefix linux/,$(libcfs-linux-objs))
 
-libcfs-all-objs := debug.o fail.o nidstrings.o lwt.o module.o tracefile.o \
+libcfs-all-objs := debug.o fail.o nidstrings.o module.o tracefile.o \
 		   watchdog.o libcfs_string.o hash.o kernel_user_comm.o \
 		   prng.o workitem.o upcall_cache.o libcfs_cpu.o \
 		   libcfs_mem.o libcfs_lock.o heap.o
diff --git a/libcfs/libcfs/darwin/darwin-prim.c b/libcfs/libcfs/darwin/darwin-prim.c
index 68d1c0d..8e0901f 100644
--- a/libcfs/libcfs/darwin/darwin-prim.c
+++ b/libcfs/libcfs/darwin/darwin-prim.c
@@ -333,24 +333,29 @@ cfs_thread_agent (void)
 
 extern thread_t kernel_thread(task_t task, void (*start)(void));
 
-int
-cfs_create_thread(cfs_thread_t  func, void *arg, unsigned long flag)
-{
-        int ret = 0;
-        thread_t th = NULL;
-
-        thread_arg_hold(&cfs_thread_arg, func, arg);
-        th = kernel_thread(kernel_task, cfs_thread_agent);
-        thread_arg_release(&cfs_thread_arg);
-        if (th == THREAD_NULL)
+cfs_task_t
+kthread_run(cfs_thread_t func, void *arg, const char namefmt[], ...)
+{
+	int ret = 0;
+	thread_t th = NULL;
+
+	thread_arg_hold(&cfs_thread_arg, func, arg);
+	th = kernel_thread(kernel_task, cfs_thread_agent);
+	thread_arg_release(&cfs_thread_arg);
+	if (th != THREAD_NULL) {
+		/*
+		 * FIXME: change child thread name...
+		 * cfs_curproc_comm() is already broken. So it is left as is...
+		va_list args;
+		va_start(args, namefmt);
+		snprintf(cfs_curproc_comm(), CFS_CURPROC_COMM_MAX,
+			 namefmt, args);
+		va_end(args);
+		 */
+	} else {
                 ret = -1;
-        return ret;
-}
-
-void cfs_daemonize(char *str)
-{
-        snprintf(cfs_curproc_comm(), CFS_CURPROC_COMM_MAX, "%s", str);
-        return;
+	}
+	return (cfs_task_t)((long)ret);
 }
 
 /*
diff --git a/libcfs/libcfs/darwin/darwin-utils.c b/libcfs/libcfs/darwin/darwin-utils.c
index c66f8e8..909b586 100644
--- a/libcfs/libcfs/darwin/darwin-utils.c
+++ b/libcfs/libcfs/darwin/darwin-utils.c
@@ -531,7 +531,7 @@ static int is_last_frame(void *addr)
 		return 1;
 	else if (is_addr_in_range(addr, trap, syscall_trace))
 		return 1;
-	else if (is_addr_in_range(addr, cfs_thread_agent, cfs_create_thread))
+	else if (is_addr_in_range(addr, cfs_thread_agent, kthread_run))
 		return 1;
 	else
 		return 0;
diff --git a/libcfs/libcfs/debug.c b/libcfs/libcfs/debug.c
index f503781..16a8e99 100644
--- a/libcfs/libcfs/debug.c
+++ b/libcfs/libcfs/debug.c
@@ -367,16 +367,16 @@ void libcfs_debug_dumplog(void)
         /* we're being careful to ensure that the kernel thread is
          * able to set our state to running as it exits before we
          * get to schedule() */
-        cfs_waitlink_init(&wait);
-        cfs_set_current_state(CFS_TASK_INTERRUPTIBLE);
-        cfs_waitq_add(&debug_ctlwq, &wait);
-
-        dumper = cfs_kthread_run(libcfs_debug_dumplog_thread,
-                                 (void*)(long)cfs_curproc_pid(),
-                                 "libcfs_debug_dumper");
-        if (IS_ERR(dumper))
-                printk(CFS_KERN_ERR "LustreError: cannot start log dump thread:"
-                       " %ld\n", PTR_ERR(dumper));
+	cfs_waitlink_init(&wait);
+	cfs_set_current_state(CFS_TASK_INTERRUPTIBLE);
+	cfs_waitq_add(&debug_ctlwq, &wait);
+
+	dumper = kthread_run(libcfs_debug_dumplog_thread,
+			     (void *)(long)cfs_curproc_pid(),
+			     "libcfs_debug_dumper");
+	if (IS_ERR(dumper))
+		printk(CFS_KERN_ERR "LustreError: cannot start log dump thread:"
+		       " %ld\n", PTR_ERR(dumper));
         else
                 cfs_waitq_wait(&wait, CFS_TASK_INTERRUPTIBLE);
 
diff --git a/libcfs/libcfs/linux/Makefile.am b/libcfs/libcfs/linux/Makefile.am
index bb75462..3c0209f 100644
--- a/libcfs/libcfs/linux/Makefile.am
+++ b/libcfs/libcfs/linux/Makefile.am
@@ -1,4 +1,4 @@
-EXTRA_DIST = linux-debug.c linux-lwt.c linux-prim.c linux-tracefile.c	\
+EXTRA_DIST = linux-debug.c linux-prim.c linux-tracefile.c	\
 	linux-fs.c linux-mem.c linux-proc.c linux-utils.c linux-lock.c	\
 	linux-module.c linux-sync.c linux-curproc.c linux-tcpip.c	\
 	linux-cpu.c linux-crypto.c linux-crypto-crc32.c linux-crypto-adler.c \
diff --git a/libcfs/libcfs/linux/linux-lwt.c b/libcfs/libcfs/linux/linux-lwt.c
deleted file mode 100644
index d9d4dc1..0000000
--- a/libcfs/libcfs/linux/linux-lwt.c
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * GPL HEADER START
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 only,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License version 2 for more details (a copy is included
- * in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU General Public License
- * version 2 along with this program; If not, see
- * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- * GPL HEADER END
- */
-/*
- * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
- * Use is subject to license terms.
- *
- * Copyright (c) 2012, Intel Corporation.
- */
-/*
- * This file is part of Lustre, http://www.lustre.org/
- * Lustre is a trademark of Sun Microsystems, Inc.
- */
-
-# define DEBUG_SUBSYSTEM S_LNET
-#include <linux/module.h>
-#include <linux/sched.h>
-#include <linux/spinlock.h>
-
-#ifdef HAVE_LINUX_OOM_H
-#include <linux/oom.h>
-#else
-#include <linux/mm.h>
-#endif
-
-int oom_get_adj(struct task_struct *task, int scope)
-{
-	int oom_adj;
-#ifdef HAVE_OOMADJ_IN_SIG
-	unsigned long flags;
-
-	spin_lock_irqsave(&task->sighand->siglock, flags);
-	oom_adj = task->signal->oom_adj;
-	task->signal->oom_adj = scope;
-	spin_unlock_irqrestore(&task->sighand->siglock, flags);
-
-#else
-	oom_adj = task->oomkilladj;
-	task->oomkilladj = scope;
-#endif
-	return oom_adj;
-}
-
-int cfs_create_thread(int (*fn)(void *),
-                      void *arg, unsigned long flags)
-{
-        void *orig_info = current->journal_info;
-        int rc;
-        int old_oom;
-
-        old_oom = oom_get_adj(current, OOM_DISABLE);
-        current->journal_info = NULL;
-        rc = kernel_thread(fn, arg, flags);
-        current->journal_info = orig_info;
-        oom_get_adj(current, old_oom);
-
-        return rc;
-}
-EXPORT_SYMBOL(cfs_create_thread);
diff --git a/libcfs/libcfs/linux/linux-prim.c b/libcfs/libcfs/linux/linux-prim.c
index afb4465..6da1744 100644
--- a/libcfs/libcfs/linux/linux-prim.c
+++ b/libcfs/libcfs/linux/linux-prim.c
@@ -259,34 +259,20 @@ void cfs_enter_debugger(void)
 #endif
 }
 
-void cfs_daemonize(char *str) {
-        unsigned long flags;
-
-        daemonize(str);
-        SIGNAL_MASK_LOCK(current, flags);
-        sigfillset(&current->blocked);
-        RECALC_SIGPENDING;
-        SIGNAL_MASK_UNLOCK(current, flags);
-}
-
-int cfs_daemonize_ctxt(char *str) {
-
-        cfs_daemonize(str);
 #ifndef HAVE_UNSHARE_FS_STRUCT
-        {
-        struct task_struct *tsk = current;
-        struct fs_struct *fs = NULL;
-        fs = copy_fs_struct(tsk->fs);
-        if (fs == NULL)
-                return -ENOMEM;
-        exit_fs(tsk);
-        tsk->fs = fs;
-        }
-#else
-        unshare_fs_struct();
+int unshare_fs_struct(void)
+{
+	struct task_struct *tsk = current;
+	struct fs_struct *fs = NULL;
+	fs = copy_fs_struct(tsk->fs);
+	if (fs == NULL)
+		return -ENOMEM;
+	exit_fs(tsk);
+	tsk->fs = fs;
+	return 0;
+}
+EXPORT_SYMBOL(unshare_fs_struct);
 #endif
-        return 0;
-}
 
 sigset_t
 cfs_block_allsigs(void)
@@ -373,8 +359,6 @@ libcfs_arch_cleanup(void)
 EXPORT_SYMBOL(libcfs_arch_init);
 EXPORT_SYMBOL(libcfs_arch_cleanup);
 EXPORT_SYMBOL(cfs_enter_debugger);
-EXPORT_SYMBOL(cfs_daemonize);
-EXPORT_SYMBOL(cfs_daemonize_ctxt);
 EXPORT_SYMBOL(cfs_block_allsigs);
 EXPORT_SYMBOL(cfs_block_sigs);
 EXPORT_SYMBOL(cfs_block_sigsinv);
diff --git a/libcfs/libcfs/tracefile.c b/libcfs/libcfs/tracefile.c
index d455e42..f874974 100644
--- a/libcfs/libcfs/tracefile.c
+++ b/libcfs/libcfs/tracefile.c
@@ -992,7 +992,6 @@ static int tracefiled(void *arg)
 
 	/* we're started late enough that we pick up init's fs context */
 	/* this is so broken in uml?  what on earth is going on? */
-	cfs_daemonize("ktracefiled");
 
 	spin_lock_init(&pc.pc_lock);
 	complete(&tctl->tctl_start);
@@ -1106,16 +1105,16 @@ int cfs_trace_start_thread(void)
 
 	init_completion(&tctl->tctl_start);
 	init_completion(&tctl->tctl_stop);
-        cfs_waitq_init(&tctl->tctl_waitq);
-        cfs_atomic_set(&tctl->tctl_shutdown, 0);
+	cfs_waitq_init(&tctl->tctl_waitq);
+	cfs_atomic_set(&tctl->tctl_shutdown, 0);
 
-        if (cfs_create_thread(tracefiled, tctl, 0) < 0) {
-                rc = -ECHILD;
-                goto out;
-        }
+	if (IS_ERR(kthread_run(tracefiled, tctl, "ktracefiled"))) {
+		rc = -ECHILD;
+		goto out;
+	}
 
 	wait_for_completion(&tctl->tctl_start);
-        thread_running = 1;
+	thread_running = 1;
 out:
 	mutex_unlock(&cfs_trace_thread_mutex);
         return rc;
diff --git a/libcfs/libcfs/user-prim.c b/libcfs/libcfs/user-prim.c
index eb21418..9f2b7b3 100644
--- a/libcfs/libcfs/user-prim.c
+++ b/libcfs/libcfs/user-prim.c
@@ -223,24 +223,25 @@ static void *cfs_thread_helper(void *data)
         return NULL;
 }
 
-int cfs_create_thread(cfs_thread_t func, void *arg, unsigned long flags)
+void *kthread_run(cfs_thread_t func, void *arg, const char namefmt[], ...)
 {
-        pthread_t tid;
-        pthread_attr_t tattr;
-        int rc;
-        struct lustre_thread_arg *targ_p = malloc(sizeof(struct lustre_thread_arg));
+	pthread_t tid;
+	pthread_attr_t tattr;
+	int rc;
+	struct lustre_thread_arg *targ_p =
+				malloc(sizeof(struct lustre_thread_arg));
 
-        if ( targ_p == NULL )
-                return -ENOMEM;
+	if (targ_p == NULL)
+		return ERR_PTR(-ENOMEM);
 
-        targ_p->f = func;
-        targ_p->arg = arg;
+	targ_p->f = func;
+	targ_p->arg = arg;
 
-        pthread_attr_init(&tattr);
-        pthread_attr_setdetachstate(&tattr, PTHREAD_CREATE_DETACHED);
-        rc = pthread_create(&tid, &tattr, cfs_thread_helper, targ_p);
-        pthread_attr_destroy(&tattr);
-        return -rc;
+	pthread_attr_init(&tattr);
+	pthread_attr_setdetachstate(&tattr, PTHREAD_CREATE_DETACHED);
+	rc = pthread_create(&tid, &tattr, cfs_thread_helper, targ_p);
+	pthread_attr_destroy(&tattr);
+	return ERR_PTR(rc);
 }
 #endif
 
@@ -314,14 +315,9 @@ void cfs_enter_debugger(void)
          */
 }
 
-void cfs_daemonize(char *str)
+int unshare_fs_struct()
 {
-        return;
-}
-
-int cfs_daemonize_ctxt(char *str)
-{
-        return 0;
+	return 0;
 }
 
 cfs_sigset_t cfs_block_allsigs(void)
diff --git a/libcfs/libcfs/watchdog.c b/libcfs/libcfs/watchdog.c
index e08fe68..0981a2c 100644
--- a/libcfs/libcfs/watchdog.c
+++ b/libcfs/libcfs/watchdog.c
@@ -213,19 +213,11 @@ static void lcw_dump_stack(struct lc_watchdog *lcw)
 static int lcw_dispatch_main(void *data)
 {
         int                 rc = 0;
-        unsigned long       flags;
         struct lc_watchdog *lcw;
         CFS_LIST_HEAD      (zombies);
 
         ENTRY;
 
-        cfs_daemonize("lc_watchdogd");
-
-        SIGNAL_MASK_LOCK(current, flags);
-        sigfillset(&current->blocked);
-        RECALC_SIGPENDING;
-        SIGNAL_MASK_UNLOCK(current, flags);
-
 	complete(&lcw_start_completion);
 
         while (1) {
@@ -312,7 +304,7 @@ static int lcw_dispatch_main(void *data)
 
 static void lcw_dispatch_start(void)
 {
-	int rc;
+	cfs_task_t *task;
 
 	ENTRY;
 	LASSERT(lcw_refcount == 1);
@@ -321,13 +313,14 @@ static void lcw_dispatch_start(void)
 	init_completion(&lcw_start_completion);
         cfs_waitq_init(&lcw_event_waitq);
 
-        CDEBUG(D_INFO, "starting dispatch thread\n");
-        rc = cfs_create_thread(lcw_dispatch_main, NULL, 0);
-        if (rc < 0) {
-                CERROR("error spawning watchdog dispatch thread: %d\n", rc);
-                EXIT;
-                return;
-        }
+	CDEBUG(D_INFO, "starting dispatch thread\n");
+	task = kthread_run(lcw_dispatch_main, NULL, "lc_watchdogd");
+	if (IS_ERR(task)) {
+		CERROR("error spawning watchdog dispatch thread: %ld\n",
+			PTR_ERR(task));
+		EXIT;
+		return;
+	}
 	wait_for_completion(&lcw_start_completion);
 	CDEBUG(D_INFO, "watchdog dispatcher initialization complete.\n");
 
diff --git a/libcfs/libcfs/winnt/winnt-prim.c b/libcfs/libcfs/winnt/winnt-prim.c
index 8596a40..1d04567 100644
--- a/libcfs/libcfs/winnt/winnt-prim.c
+++ b/libcfs/libcfs/winnt/winnt-prim.c
@@ -82,22 +82,22 @@ cfs_thread_proc(
 }
 
 /*
- * cfs_create_thread
+ * kthread_run
  *   Create a system thread to execute the routine specified
  *
  * Arguments:
  *   func:  function to be executed in the thread
  *   arg:   argument transferred to func function
- *   flag:  thread creation flags.
+ *   name:  thread name to create
  *
  * Return Value:
- *   int:   0 on success or error codes
+ *   cfs_task_t:   0 on success or error codes
  *
  * Notes:
  *   N/A
  */
 
-int cfs_create_thread(int (*func)(void *), void *arg, unsigned long flag)
+cfs_task_t kthread_run(int (*func)(void *), void *arg, char *name)
 {
     cfs_handle_t  thread = NULL;
     NTSTATUS      status;
@@ -108,7 +108,7 @@ int cfs_create_thread(int (*func)(void *), void *arg, unsigned long flag)
     context = cfs_alloc(sizeof(cfs_thread_context_t), CFS_ALLOC_ZERO);
 
     if (!context) {
-        return -ENOMEM;
+	return ERR_PTR(-ENOMEM);
     }
 
     context->func  = func;
@@ -130,7 +130,7 @@ int cfs_create_thread(int (*func)(void *), void *arg, unsigned long flag)
 
         /* We need translate the nt status to linux error code */
 
-        return cfs_error_code(status);
+	return ERR_PTR(cfs_error_code(status));
     }
 
     //
@@ -139,7 +139,7 @@ int cfs_create_thread(int (*func)(void *), void *arg, unsigned long flag)
 
     ZwClose(thread);
 
-    return 0;
+	return (cfs_task_t)0;
 }
 
 
@@ -529,18 +529,9 @@ cfs_time_t cfs_timer_deadline(cfs_timer_t * timer)
     return timer->deadline;
 }
 
-/*
- * daemonize routine stub
- */
-
-void cfs_daemonize(char *str)
+int unshare_fs_struct()
 {
-    return;
-}
-
-int cfs_daemonize_ctxt(char *str) {
-    cfs_daemonize(str);
-    return 0;
+	return 0;
 }
 
 /*
diff --git a/libcfs/libcfs/winnt/winnt-tcpip.c b/libcfs/libcfs/winnt/winnt-tcpip.c
index 6fbf0a5..50d784f 100644
--- a/libcfs/libcfs/winnt/winnt-tcpip.c
+++ b/libcfs/libcfs/winnt/winnt-tcpip.c
@@ -5898,10 +5898,10 @@ ks_init_tdi_data()
     }
     for (i = 0; i < ks_data.ksnd_engine_nums; i++) {
 		spin_lock_init(&ks_data.ksnd_engine_mgr[i].lock);
-        cfs_init_event(&ks_data.ksnd_engine_mgr[i].start, TRUE, FALSE);
-        cfs_init_event(&ks_data.ksnd_engine_mgr[i].exit, TRUE, FALSE);
-        CFS_INIT_LIST_HEAD(&ks_data.ksnd_engine_mgr[i].list);
-        cfs_create_thread(KsDeliveryEngineThread, &ks_data.ksnd_engine_mgr[i], 0);
+	cfs_init_event(&ks_data.ksnd_engine_mgr[i].start, TRUE, FALSE);
+	cfs_init_event(&ks_data.ksnd_engine_mgr[i].exit, TRUE, FALSE);
+	CFS_INIT_LIST_HEAD(&ks_data.ksnd_engine_mgr[i].list);
+	kthread_run(KsDeliveryEngineThread, &ks_data.ksnd_engine_mgr[i], "");
     }
 
     /* register pnp handlers to watch network condition */
diff --git a/libcfs/libcfs/workitem.c b/libcfs/libcfs/workitem.c
index db839e5..309cfec 100644
--- a/libcfs/libcfs/workitem.c
+++ b/libcfs/libcfs/workitem.c
@@ -245,17 +245,7 @@ static int
 cfs_wi_scheduler (void *arg)
 {
 	struct cfs_wi_sched	*sched = (cfs_wi_sched_t *)arg;
-	char			name[16];
-
-	if (sched->ws_cptab != NULL && sched->ws_cpt >= 0) {
-		snprintf(name, sizeof(name), "%s_%02d_%02d",
-			 sched->ws_name, sched->ws_cpt, sched->ws_nthreads);
-	} else {
-		snprintf(name, sizeof(name), "%s_%02d",
-			 sched->ws_name, sched->ws_nthreads);
-	}
 
-	cfs_daemonize(name);
 	cfs_block_allsigs();
 
 	/* CPT affinity scheduler? */
@@ -463,6 +453,8 @@ cfs_wi_sched_create(char *name, struct cfs_cpt_table *cptab,
 	rc = 0;
 #ifdef __KERNEL__
 	while (nthrs > 0)  {
+		char	name[16];
+		cfs_task_t	*task;
 		spin_lock(&cfs_wi_data.wi_glock);
 		while (sched->ws_starting > 0) {
 			spin_unlock(&cfs_wi_data.wi_glock);
@@ -473,11 +465,21 @@ cfs_wi_sched_create(char *name, struct cfs_cpt_table *cptab,
 		sched->ws_starting++;
 		spin_unlock(&cfs_wi_data.wi_glock);
 
-		rc = cfs_create_thread(cfs_wi_scheduler, sched, 0);
-		if (rc >= 0) {
+		if (sched->ws_cptab != NULL && sched->ws_cpt >= 0) {
+			snprintf(name, sizeof(name), "%s_%02d_%02d",
+				 sched->ws_name, sched->ws_cpt,
+				 sched->ws_nthreads);
+		} else {
+			snprintf(name, sizeof(name), "%s_%02d",
+				 sched->ws_name, sched->ws_nthreads);
+		}
+
+		task = kthread_run(cfs_wi_scheduler, sched, name);
+		if (!IS_ERR(task)) {
 			nthrs--;
 			continue;
 		}
+		rc = PTR_ERR(task);
 
 		CERROR("Failed to create thread for WI scheduler %s: %d\n",
 		       name, rc);
diff --git a/lnet/klnds/gnilnd/gnilnd_cb.c b/lnet/klnds/gnilnd/gnilnd_cb.c
index 56be88a..53d8337 100644
--- a/lnet/klnds/gnilnd/gnilnd_cb.c
+++ b/lnet/klnds/gnilnd/gnilnd_cb.c
@@ -2609,7 +2609,6 @@ kgnilnd_reaper(void *arg)
 	struct timer_list  timer;
 	DEFINE_WAIT(wait);
 
-	cfs_daemonize("kgnilnd_rpr");
 	cfs_block_allsigs();
 
 	/* all gnilnd threads need to run fairly urgently */
@@ -4247,14 +4246,11 @@ kgnilnd_scheduler(void *arg)
 {
 	int               threadno = (long)arg;
 	kgn_device_t     *dev;
-	char              name[16];
 	int               busy_loops = 0;
 	DEFINE_WAIT(wait);
 
 	dev = &kgnilnd_data.kgn_devices[(threadno + 1) % kgnilnd_data.kgn_ndevs];
 
-	snprintf(name, sizeof(name), "kgnilnd_sd_%02d", threadno);
-	cfs_daemonize(name);
 	cfs_block_allsigs();
 
 	/* all gnilnd threads need to run fairly urgently */
diff --git a/lnet/klnds/gnilnd/gnilnd_conn.c b/lnet/klnds/gnilnd/gnilnd_conn.c
index 38aee5b..a64ed3f 100644
--- a/lnet/klnds/gnilnd/gnilnd_conn.c
+++ b/lnet/klnds/gnilnd/gnilnd_conn.c
@@ -2157,13 +2157,10 @@ int
 kgnilnd_dgram_waitq(void *arg)
 {
 	kgn_device_t     *dev = (kgn_device_t *) arg;
-	char              name[16];
 	gni_return_t      grc;
 	__u64             readyid;
 	DEFINE_WAIT(mover_done);
 
-	snprintf(name, sizeof(name), "kgnilnd_dgn_%02d", dev->gnd_id);
-	cfs_daemonize(name);
 	cfs_block_allsigs();
 
 	/* all gnilnd threads need to run fairly urgently */
@@ -2312,15 +2309,12 @@ int
 kgnilnd_dgram_mover(void *arg)
 {
 	kgn_device_t            *dev = (kgn_device_t *)arg;
-	char                     name[16];
 	int                      rc, did_something;
 	unsigned long            next_purge_check = jiffies - 1;
 	unsigned long            timeout;
 	struct timer_list        timer;
 	DEFINE_WAIT(wait);
 
-	snprintf(name, sizeof(name), "kgnilnd_dg_%02d", dev->gnd_id);
-	cfs_daemonize(name);
 	cfs_block_allsigs();
 	/* all gnilnd threads need to run fairly urgently */
 	set_user_nice(current, *kgnilnd_tunables.kgn_nice);
diff --git a/lnet/klnds/gnilnd/gnilnd_stack.c b/lnet/klnds/gnilnd/gnilnd_stack.c
index 10ae493..9dbc3a1 100644
--- a/lnet/klnds/gnilnd/gnilnd_stack.c
+++ b/lnet/klnds/gnilnd/gnilnd_stack.c
@@ -362,7 +362,6 @@ kgnilnd_ruhroh_thread(void *arg)
 	int                i = 1;
 	DEFINE_WAIT(wait);
 
-	cfs_daemonize("kgnilnd_rr");
 	cfs_block_allsigs();
 	set_user_nice(current, *kgnilnd_tunables.kgn_nice);
 	kgnilnd_data.kgn_ruhroh_running = 1;
diff --git a/lnet/klnds/mxlnd/mxlnd.c b/lnet/klnds/mxlnd/mxlnd.c
index 558bfaf..dbe998f 100644
--- a/lnet/klnds/mxlnd/mxlnd.c
+++ b/lnet/klnds/mxlnd/mxlnd.c
@@ -385,24 +385,25 @@ failed_with_init:
  * mxlnd_thread_start - spawn a kernel thread with this function
  * @fn - function pointer
  * @arg - pointer to the parameter data
+ * @name - name of new thread
  *
  * Returns 0 on success and a negative value on failure
  */
 int
-mxlnd_thread_start(int (*fn)(void *arg), void *arg)
+mxlnd_thread_start(int (*fn)(void *arg), void *arg, char *name)
 {
-        int     pid = 0;
+	cfs_task *task;
         int     i   = (int) ((long) arg);
 
         cfs_atomic_inc(&kmxlnd_data.kmx_nthreads);
 	init_completion(&kmxlnd_data.kmx_completions[i]);
 
-        pid = cfs_create_thread(fn, arg, 0);
-        if (pid < 0) {
-                CERROR("cfs_create_thread() failed with %d\n", pid);
-                cfs_atomic_dec(&kmxlnd_data.kmx_nthreads);
-        }
-        return pid;
+	task = kthread_run(fn, arg, name);
+	if (IS_ERR(task)) {
+		CERROR("cfs_create_thread() failed with %d\n", PTR_ERR(task));
+		cfs_atomic_dec(&kmxlnd_data.kmx_nthreads);
+	}
+	return PTR_ERR(task);
 }
 
 /**
@@ -616,9 +617,13 @@ mxlnd_startup (lnet_ni_t *ni)
                 *kmxlnd_tunables.kmx_n_waitd == 1 ? "thread" : "threads");
 
         for (i = 0; i < *kmxlnd_tunables.kmx_n_waitd; i++) {
+		char                    name[24];
+		memset(name, 0, sizeof(name));
+		snprintf(name, sizeof(name), "mxlnd_request_waitd_%02ld", i);
                 ret = mxlnd_thread_start(mxlnd_request_waitd, (void*)((long)i));
-                if (ret < 0) {
-                        CERROR("Starting mxlnd_request_waitd[%d] failed with %d\n", i, ret);
+		if (ret < 0) {
+			CERROR("Starting mxlnd_request_waitd[%d] "
+				"failed with %d\n", i, ret);
                         cfs_atomic_set(&kmxlnd_data.kmx_shutdown, 1);
                         mx_wakeup(kmxlnd_data.kmx_endpt);
                         for (--i; i >= 0; i--) {
@@ -631,7 +636,8 @@ mxlnd_startup (lnet_ni_t *ni)
                         goto failed;
                 }
         }
-        ret = mxlnd_thread_start(mxlnd_tx_queued, (void*)((long)i++));
+	ret = mxlnd_thread_start(mxlnd_tx_queued, (void *)((long)i++),
+				 "mxlnd_tx_queued");
         if (ret < 0) {
                 CERROR("Starting mxlnd_tx_queued failed with %d\n", ret);
                 cfs_atomic_set(&kmxlnd_data.kmx_shutdown, 1);
@@ -644,7 +650,8 @@ mxlnd_startup (lnet_ni_t *ni)
 			nthreads * sizeof(struct completion));
                 goto failed;
         }
-        ret = mxlnd_thread_start(mxlnd_timeoutd, (void*)((long)i++));
+	ret = mxlnd_thread_start(mxlnd_timeoutd, (void *)((long)i++),
+				 "mxlnd_timeoutd");
         if (ret < 0) {
                 CERROR("Starting mxlnd_timeoutd failed with %d\n", ret);
                 cfs_atomic_set(&kmxlnd_data.kmx_shutdown, 1);
@@ -658,7 +665,8 @@ mxlnd_startup (lnet_ni_t *ni)
 			nthreads * sizeof(struct completion));
                 goto failed;
         }
-        ret = mxlnd_thread_start(mxlnd_connd, (void*)((long)i++));
+	ret = mxlnd_thread_start(mxlnd_connd, (void *)((long)i++),
+				 "mxlnd_connd");
         if (ret < 0) {
                 CERROR("Starting mxlnd_connd failed with %d\n", ret);
                 cfs_atomic_set(&kmxlnd_data.kmx_shutdown, 1);
diff --git a/lnet/klnds/mxlnd/mxlnd_cb.c b/lnet/klnds/mxlnd/mxlnd_cb.c
index 5b67392..4b3961b 100644
--- a/lnet/klnds/mxlnd/mxlnd_cb.c
+++ b/lnet/klnds/mxlnd/mxlnd_cb.c
@@ -2554,8 +2554,6 @@ mxlnd_tx_queued(void *arg)
 	spinlock_t		*tx_q_lock = &kmxlnd_data.kmx_tx_queue_lock;
 	rwlock_t		*g_lock  = &kmxlnd_data.kmx_global_lock;
 
-	cfs_daemonize("mxlnd_tx_queued");
-
 	while (!(cfs_atomic_read(&kmxlnd_data.kmx_shutdown))) {
 		ret = down_interruptible(&kmxlnd_data.kmx_tx_queue_sem);
 		if (cfs_atomic_read(&kmxlnd_data.kmx_shutdown))
@@ -3485,7 +3483,6 @@ int
 mxlnd_request_waitd(void *arg)
 {
         long                    id              = (long) arg;
-        char                    name[24];
         __u32                   result          = 0;
         mx_return_t             mxret           = MX_SUCCESS;
         mx_status_t             status;
@@ -3497,10 +3494,6 @@ mxlnd_request_waitd(void *arg)
         int                     count           = 0;
 #endif
 
-        memset(name, 0, sizeof(name));
-        snprintf(name, sizeof(name), "mxlnd_request_waitd_%02ld", id);
-        cfs_daemonize(name);
-
         memset(&status, 0, sizeof(status));
 
         CDEBUG(D_NET, "%s starting\n", name);
@@ -3965,8 +3958,6 @@ mxlnd_connd(void *arg)
 {
         long                    id              = (long) arg;
 
-        cfs_daemonize("mxlnd_connd");
-
         CDEBUG(D_NET, "connd starting\n");
 
         while (!(cfs_atomic_read(&kmxlnd_data.kmx_shutdown))) {
@@ -4040,8 +4031,6 @@ mxlnd_timeoutd(void *arg)
         kmx_conn_t     *conn    = NULL;
 	rwlock_t   *g_lock  = &kmxlnd_data.kmx_global_lock;
 
-        cfs_daemonize("mxlnd_timeoutd");
-
         CDEBUG(D_NET, "timeoutd starting\n");
 
         while (!(cfs_atomic_read(&kmxlnd_data.kmx_shutdown))) {
diff --git a/lnet/klnds/o2iblnd/o2iblnd.c b/lnet/klnds/o2iblnd/o2iblnd.c
index 7d3c025..86298dd 100644
--- a/lnet/klnds/o2iblnd/o2iblnd.c
+++ b/lnet/klnds/o2iblnd/o2iblnd.c
@@ -3011,14 +3011,15 @@ kiblnd_base_startup(void)
         kiblnd_data.kib_init = IBLND_INIT_DATA;
         /*****************************************************/
 
-        rc = kiblnd_thread_start(kiblnd_connd, NULL);
+	rc = kiblnd_thread_start(kiblnd_connd, NULL, "kiblnd_connd");
         if (rc != 0) {
                 CERROR("Can't spawn o2iblnd connd: %d\n", rc);
                 goto failed;
         }
 
-        if (*kiblnd_tunables.kib_dev_failover != 0)
-                rc = kiblnd_thread_start(kiblnd_failover_thread, NULL);
+	if (*kiblnd_tunables.kib_dev_failover != 0)
+		rc = kiblnd_thread_start(kiblnd_failover_thread, NULL,
+					 "kiblnd_failover");
 
         if (rc != 0) {
                 CERROR("Can't spawn o2iblnd failover thread: %d\n", rc);
@@ -3060,9 +3061,11 @@ kiblnd_start_schedulers(struct kib_sched_info *sched)
 
 	for (i = 0; i < nthrs; i++) {
 		long	id;
-
+		char	name[20];
 		id = KIB_THREAD_ID(sched->ibs_cpt, sched->ibs_nthreads + i);
-		rc = kiblnd_thread_start(kiblnd_scheduler, (void *)id);
+		snprintf(name, sizeof(name), "kiblnd_sd_%02ld_%02ld",
+			 KIB_THREAD_CPT(id), KIB_THREAD_TID(id));
+		rc = kiblnd_thread_start(kiblnd_scheduler, (void *)id, name);
 		if (rc == 0)
 			continue;
 
diff --git a/lnet/klnds/o2iblnd/o2iblnd.h b/lnet/klnds/o2iblnd/o2iblnd.h
index 87c7cc0..7585657 100644
--- a/lnet/klnds/o2iblnd/o2iblnd.h
+++ b/lnet/klnds/o2iblnd/o2iblnd.h
@@ -1067,7 +1067,7 @@ void kiblnd_tunables_fini(void);
 
 int  kiblnd_connd (void *arg);
 int  kiblnd_scheduler(void *arg);
-int  kiblnd_thread_start (int (*fn)(void *arg), void *arg);
+int  kiblnd_thread_start(int (*fn)(void *arg), void *arg, char *name);
 int  kiblnd_failover_thread (void *arg);
 
 int  kiblnd_alloc_pages(kib_pages_t **pp, int cpt, int npages);
diff --git a/lnet/klnds/o2iblnd/o2iblnd_cb.c b/lnet/klnds/o2iblnd/o2iblnd_cb.c
index 3cc7985..af92311 100644
--- a/lnet/klnds/o2iblnd/o2iblnd_cb.c
+++ b/lnet/klnds/o2iblnd/o2iblnd_cb.c
@@ -1805,15 +1805,15 @@ kiblnd_recv (lnet_ni_t *ni, void *private, lnet_msg_t *lntmsg, int delayed,
 }
 
 int
-kiblnd_thread_start (int (*fn)(void *arg), void *arg)
+kiblnd_thread_start(int (*fn)(void *arg), void *arg, char *name)
 {
-        long    pid = cfs_create_thread (fn, arg, 0);
+	cfs_task_t *task = kthread_run(fn, arg, name);
 
-        if (pid < 0)
-                return ((int)pid);
+	if (IS_ERR(task))
+		return PTR_ERR(task);
 
-        cfs_atomic_inc (&kiblnd_data.kib_nthreads);
-        return (0);
+	cfs_atomic_inc(&kiblnd_data.kib_nthreads);
+	return 0;
 }
 
 void
@@ -3135,7 +3135,6 @@ kiblnd_connd (void *arg)
         int                peer_index = 0;
         unsigned long      deadline = jiffies;
 
-        cfs_daemonize ("kiblnd_connd");
         cfs_block_allsigs ();
 
         cfs_waitlink_init (&wait);
@@ -3329,15 +3328,10 @@ kiblnd_scheduler(void *arg)
 	cfs_waitlink_t		wait;
 	unsigned long		flags;
 	struct ib_wc		wc;
-	char			name[20];
 	int			did_something;
 	int			busy_loops = 0;
 	int			rc;
 
-	snprintf(name, sizeof(name), "kiblnd_sd_%02ld_%02ld",
-		 KIB_THREAD_CPT(id), KIB_THREAD_TID(id));
-
-	cfs_daemonize(name);
 	cfs_block_allsigs();
 
 	cfs_waitlink_init(&wait);
@@ -3346,10 +3340,10 @@ kiblnd_scheduler(void *arg)
 
 	rc = cfs_cpt_bind(lnet_cpt_table(), sched->ibs_cpt);
 	if (rc != 0) {
-		CWARN("Failed to bind %s on CPT %d, please verify whether "
+		CWARN("Failed to bind on CPT %d, please verify whether "
 		      "all CPUs are healthy and reload modules if necessary, "
 		      "otherwise your system might under risk of low "
-		      "performance\n", name, sched->ibs_cpt);
+		      "performance\n", sched->ibs_cpt);
 	}
 
 	spin_lock_irqsave(&sched->ibs_lock, flags);
@@ -3464,7 +3458,6 @@ kiblnd_failover_thread(void *arg)
 
         LASSERT (*kiblnd_tunables.kib_dev_failover != 0);
 
-        cfs_daemonize ("kiblnd_failover");
         cfs_block_allsigs ();
 
         cfs_waitlink_init(&wait);
diff --git a/lnet/klnds/ptllnd/ptllnd.c b/lnet/klnds/ptllnd/ptllnd.c
index 791f5c2..2edf87d 100644
--- a/lnet/klnds/ptllnd/ptllnd.c
+++ b/lnet/klnds/ptllnd/ptllnd.c
@@ -643,6 +643,7 @@ kptllnd_base_startup (void)
         struct timeval  tv;
         lnet_process_id_t  target;
         ptl_err_t       ptl_rc;
+	char            name[16];
 
         if (*kptllnd_tunables.kptl_max_procs_per_node < 1) {
                 CERROR("max_procs_per_node must be >= 1\n");
@@ -824,6 +825,7 @@ kptllnd_base_startup (void)
          * now that PTLLND_INIT_DATA state has been entered */
         CDEBUG(D_NET, "starting %d scheduler threads\n", PTLLND_N_SCHED);
         for (i = 0; i < PTLLND_N_SCHED; i++) {
+		snprintf(name, sizeof(name), "kptllnd_sd_%02d", i);
                 rc = kptllnd_thread_start(kptllnd_scheduler, (void *)((long)i));
                 if (rc != 0) {
                         CERROR("Can't spawn scheduler[%d]: %d\n", i, rc);
@@ -831,7 +833,8 @@ kptllnd_base_startup (void)
                 }
         }
 
-        rc = kptllnd_thread_start(kptllnd_watchdog, NULL);
+	snprintf(name, sizeof(name), "kptllnd_wd_%02d", i);
+	rc = kptllnd_thread_start(kptllnd_watchdog, NULL, name);
         if (rc != 0) {
                 CERROR("Can't spawn watchdog: %d\n", rc);
                 goto failed;
diff --git a/lnet/klnds/ptllnd/ptllnd_cb.c b/lnet/klnds/ptllnd/ptllnd_cb.c
index e815607..7be7e4d 100644
--- a/lnet/klnds/ptllnd/ptllnd_cb.c
+++ b/lnet/klnds/ptllnd/ptllnd_cb.c
@@ -651,26 +651,24 @@ kptllnd_thread_fini (void)
 }
 
 int
-kptllnd_thread_start (int (*fn)(void *arg), void *arg)
+kptllnd_thread_start(int (*fn)(void *arg), void *arg, char *name)
 {
-        long                pid;
+	cfs_task_t *task;
 
-        cfs_atomic_inc(&kptllnd_data.kptl_nthreads);
+	cfs_atomic_inc(&kptllnd_data.kptl_nthreads);
 
-        pid = cfs_create_thread (fn, arg, 0);
-        if (pid >= 0)
-                return 0;
-
-        CERROR("Failed to start thread: error %d\n", (int)pid);
-        kptllnd_thread_fini();
-        return (int)pid;
+	task = kthread_run(fn, arg, name);
+	if (IS_ERR(task)) {
+		CERROR("Failed to start thread: error %ld\n", PTR_ERR(task));
+		kptllnd_thread_fini();
+	}
+	return PTR_ERR(task);
 }
 
 int
 kptllnd_watchdog(void *arg)
 {
         int                 id = (long)arg;
-        char                name[16];
         cfs_waitlink_t      waitlink;
         int                 stamp = 0;
         int                 peer_index = 0;
@@ -678,8 +676,6 @@ kptllnd_watchdog(void *arg)
         int                 timeout;
         int                 i;
 
-        snprintf(name, sizeof(name), "kptllnd_wd_%02d", id);
-        cfs_daemonize(name);
         cfs_block_allsigs();
 
         cfs_waitlink_init(&waitlink);
@@ -740,7 +736,6 @@ int
 kptllnd_scheduler (void *arg)
 {
         int                 id = (long)arg;
-        char                name[16];
         cfs_waitlink_t      waitlink;
         unsigned long       flags;
         int                 did_something;
@@ -749,8 +744,6 @@ kptllnd_scheduler (void *arg)
         kptl_rx_buffer_t   *rxb;
         kptl_tx_t          *tx;
 
-        snprintf(name, sizeof(name), "kptllnd_sd_%02d", id);
-        cfs_daemonize(name);
         cfs_block_allsigs();
 
         cfs_waitlink_init(&waitlink);
diff --git a/lnet/klnds/qswlnd/qswlnd.c b/lnet/klnds/qswlnd/qswlnd.c
index eb6c659..4df26ee 100644
--- a/lnet/klnds/qswlnd/qswlnd.c
+++ b/lnet/klnds/qswlnd/qswlnd.c
@@ -526,7 +526,8 @@ kqswnal_startup (lnet_ni_t *ni)
 	/**********************************************************************/
 	/* Spawn scheduling threads */
 	for (i = 0; i < cfs_num_online_cpus(); i++) {
-		rc = kqswnal_thread_start (kqswnal_scheduler, NULL);
+		rc = kqswnal_thread_start(kqswnal_scheduler, NULL,
+					  "kqswnal_sched");
 		if (rc != 0)
 		{
 			CERROR ("failed to spawn scheduling thread: %d\n", rc);
diff --git a/lnet/klnds/qswlnd/qswlnd_cb.c b/lnet/klnds/qswlnd/qswlnd_cb.c
index 243918b..50cc744 100644
--- a/lnet/klnds/qswlnd/qswlnd_cb.c
+++ b/lnet/klnds/qswlnd/qswlnd_cb.c
@@ -1655,15 +1655,15 @@ kqswnal_recv (lnet_ni_t     *ni,
 }
 
 int
-kqswnal_thread_start (int (*fn)(void *arg), void *arg)
+kqswnal_thread_start(int (*fn)(void *arg), void *arg, char *name)
 {
-        long    pid = cfs_create_thread (fn, arg, 0);
+	cfs_task_t *task = cfs_thread_run(fn, arg, name);
 
-        if (pid < 0)
-                return ((int)pid);
+	if (IS_ERR(task))
+		return PTR_ERR(task);
 
-        cfs_atomic_inc (&kqswnal_data.kqn_nthreads);
-        return (0);
+	cfs_atomic_inc(&kqswnal_data.kqn_nthreads);
+	return 0;
 }
 
 void
@@ -1682,7 +1682,6 @@ kqswnal_scheduler (void *arg)
         int              counter = 0;
         int              did_something;
 
-        cfs_daemonize ("kqswnal_sched");
         cfs_block_allsigs ();
 
 	spin_lock_irqsave(&kqswnal_data.kqn_sched_lock, flags);
diff --git a/lnet/klnds/ralnd/ralnd.c b/lnet/klnds/ralnd/ralnd.c
index ca68fef..eabefae 100644
--- a/lnet/klnds/ralnd/ralnd.c
+++ b/lnet/klnds/ralnd/ralnd.c
@@ -1566,6 +1566,7 @@ kranal_startup (lnet_ni_t *ni)
         int               rc;
         int               i;
         kra_device_t     *dev;
+	char		  name[16];
 
         LASSERT (ni->ni_lnd == &the_kralnd);
 
@@ -1658,14 +1659,16 @@ kranal_startup (lnet_ni_t *ni)
         if (rc != 0)
                 goto failed;
 
-        rc = kranal_thread_start(kranal_reaper, NULL);
+	rc = kranal_thread_start(kranal_reaper, NULL, "kranal_reaper");
         if (rc != 0) {
                 CERROR("Can't spawn ranal reaper: %d\n", rc);
                 goto failed;
         }
 
         for (i = 0; i < *kranal_tunables.kra_n_connd; i++) {
-                rc = kranal_thread_start(kranal_connd, (void *)(unsigned long)i);
+		snprintf(name, sizeof(name), "kranal_connd_%02ld", i);
+		rc = kranal_thread_start(kranal_connd,
+					 (void *)(unsigned long)i, name);
                 if (rc != 0) {
                         CERROR("Can't spawn ranal connd[%d]: %d\n",
                                i, rc);
@@ -1691,7 +1694,8 @@ kranal_startup (lnet_ni_t *ni)
         
         for (i = 0; i < kranal_data.kra_ndevs; i++) {
                 dev = &kranal_data.kra_devices[i];
-                rc = kranal_thread_start(kranal_scheduler, dev);
+		snprintf(name, sizeof(name), "kranal_sd_%02d", dev->rad_idx);
+		rc = kranal_thread_start(kranal_scheduler, dev, name);
                 if (rc != 0) {
                         CERROR("Can't spawn ranal scheduler[%d]: %d\n",
                                i, rc);
diff --git a/lnet/klnds/ralnd/ralnd.h b/lnet/klnds/ralnd/ralnd.h
index d9fd100..8b92cdc 100644
--- a/lnet/klnds/ralnd/ralnd.h
+++ b/lnet/klnds/ralnd/ralnd.h
@@ -452,7 +452,7 @@ extern kra_peer_t *kranal_find_peer_locked (lnet_nid_t nid);
 extern void kranal_post_fma (kra_conn_t *conn, kra_tx_t *tx);
 extern int kranal_del_peer (lnet_nid_t nid);
 extern void kranal_device_callback (RAP_INT32 devid, RAP_PVOID arg);
-extern int kranal_thread_start (int(*fn)(void *arg), void *arg);
+extern int kranal_thread_start(int(*fn)(void *arg), void *arg, char *name);
 extern int kranal_connd (void *arg);
 extern int kranal_reaper (void *arg);
 extern int kranal_scheduler (void *arg);
diff --git a/lnet/klnds/ralnd/ralnd_cb.c b/lnet/klnds/ralnd/ralnd_cb.c
index 8c7f053..05de1c1 100644
--- a/lnet/klnds/ralnd/ralnd_cb.c
+++ b/lnet/klnds/ralnd/ralnd_cb.c
@@ -891,15 +891,13 @@ kranal_recv (lnet_ni_t *ni, void *private, lnet_msg_t *lntmsg,
 }
 
 int
-kranal_thread_start (int(*fn)(void *arg), void *arg)
+kranal_thread_start(int(*fn)(void *arg), void *arg, char *name)
 {
-        long    pid = cfs_create_thread(fn, arg, 0);
+	cfs_task_t *task = cfs_thread_run(fn, arg, name);
 
-        if (pid < 0)
-                return(int)pid;
-
-        cfs_atomic_inc(&kranal_data.kra_nthreads);
-        return 0;
+	if (!IS_ERR(task))
+		cfs_atomic_inc(&kranal_data.kra_nthreads);
+	return PTR_ERR(task);
 }
 
 void
@@ -1054,15 +1052,12 @@ int
 kranal_connd (void *arg)
 {
         long               id = (long)arg;
-        char               name[16];
         cfs_waitlink_t     wait;
         unsigned long      flags;
         kra_peer_t        *peer;
         kra_acceptsock_t  *ras;
         int                did_something;
 
-        snprintf(name, sizeof(name), "kranal_connd_%02ld", id);
-        cfs_daemonize(name);
         cfs_block_allsigs();
 
         cfs_waitlink_init(&wait);
@@ -1159,7 +1154,6 @@ kranal_reaper (void *arg)
         long               next_min_timeout = CFS_MAX_SCHEDULE_TIMEOUT;
         long               current_min_timeout = 1;
 
-        cfs_daemonize("kranal_reaper");
         cfs_block_allsigs();
 
         cfs_waitlink_init(&wait);
@@ -1932,7 +1926,6 @@ kranal_scheduler (void *arg)
 {
         kra_device_t     *dev = (kra_device_t *)arg;
         cfs_waitlink_t    wait;
-        char              name[16];
         kra_conn_t       *conn;
         unsigned long     flags;
         unsigned long     deadline;
@@ -1945,8 +1938,6 @@ kranal_scheduler (void *arg)
         int               dropped_lock;
         int               busy_loops = 0;
 
-        snprintf(name, sizeof(name), "kranal_sd_%02d", dev->rad_idx);
-        cfs_daemonize(name);
         cfs_block_allsigs();
 
         dev->rad_scheduler = current;
diff --git a/lnet/klnds/socklnd/socklnd.c b/lnet/klnds/socklnd/socklnd.c
index 9376b08..c70ceeb 100644
--- a/lnet/klnds/socklnd/socklnd.c
+++ b/lnet/klnds/socklnd/socklnd.c
@@ -2465,12 +2465,15 @@ ksocknal_base_startup(void)
         }
 
         for (i = 0; i < *ksocknal_tunables.ksnd_nconnds; i++) {
+		char name[16];
 		spin_lock_bh(&ksocknal_data.ksnd_connd_lock);
 		ksocknal_data.ksnd_connd_starting++;
 		spin_unlock_bh(&ksocknal_data.ksnd_connd_lock);
 
+
+		snprintf(name, sizeof(name), "socknal_cd%02d", i);
 		rc = ksocknal_thread_start(ksocknal_connd,
-					   (void *)((ulong_ptr_t)i));
+					   (void *)((ulong_ptr_t)i), name);
 		if (rc != 0) {
 			spin_lock_bh(&ksocknal_data.ksnd_connd_lock);
 			ksocknal_data.ksnd_connd_starting--;
@@ -2480,7 +2483,7 @@ ksocknal_base_startup(void)
                 }
         }
 
-        rc = ksocknal_thread_start (ksocknal_reaper, NULL);
+	rc = ksocknal_thread_start(ksocknal_reaper, NULL, "socknal_reaper");
         if (rc != 0) {
                 CERROR ("Can't spawn socknal reaper: %d\n", rc);
                 goto failed;
@@ -2724,10 +2727,16 @@ ksocknal_start_schedulers(struct ksock_sched_info *info)
 	}
 
 	for (i = 0; i < nthrs; i++) {
-		long	id;
-
+		long		id;
+		char		name[20];
+		ksock_sched_t	*sched;
 		id = KSOCK_THREAD_ID(info->ksi_cpt, info->ksi_nthreads + i);
-		rc = ksocknal_thread_start(ksocknal_scheduler, (void *)id);
+		sched = &info->ksi_scheds[KSOCK_THREAD_SID(id)];
+		snprintf(name, sizeof(name), "socknal_sd%02d_%02d",
+			 info->ksi_cpt, (int)(sched - &info->ksi_scheds[0]));
+
+		rc = ksocknal_thread_start(ksocknal_scheduler,
+					   (void *)id, name);
 		if (rc == 0)
 			continue;
 
diff --git a/lnet/klnds/socklnd/socklnd.h b/lnet/klnds/socklnd/socklnd.h
index abdf25a..1094397 100644
--- a/lnet/klnds/socklnd/socklnd.h
+++ b/lnet/klnds/socklnd/socklnd.h
@@ -581,7 +581,7 @@ extern void ksocknal_txlist_done (lnet_ni_t *ni, cfs_list_t *txlist,
                                   int error);
 extern void ksocknal_notify (lnet_ni_t *ni, lnet_nid_t gw_nid, int alive);
 extern void ksocknal_query (struct lnet_ni *ni, lnet_nid_t nid, cfs_time_t *when);
-extern int ksocknal_thread_start (int (*fn)(void *arg), void *arg);
+extern int ksocknal_thread_start(int (*fn)(void *arg), void *arg, char *name);
 extern void ksocknal_thread_fini (void);
 extern void ksocknal_launch_all_connections_locked (ksock_peer_t *peer);
 extern ksock_route_t *ksocknal_find_connectable_route_locked (ksock_peer_t *peer);
diff --git a/lnet/klnds/socklnd/socklnd_cb.c b/lnet/klnds/socklnd/socklnd_cb.c
index b24127d..e624753 100644
--- a/lnet/klnds/socklnd/socklnd_cb.c
+++ b/lnet/klnds/socklnd/socklnd_cb.c
@@ -1007,17 +1007,17 @@ ksocknal_send(lnet_ni_t *ni, void *private, lnet_msg_t *lntmsg)
 }
 
 int
-ksocknal_thread_start (int (*fn)(void *arg), void *arg)
+ksocknal_thread_start(int (*fn)(void *arg), void *arg, char *name)
 {
-        long          pid = cfs_create_thread (fn, arg, 0);
+	cfs_task_t *task = kthread_run(fn, arg, name);
 
-        if (pid < 0)
-                return ((int)pid);
+	if (IS_ERR(task))
+		return PTR_ERR(task);
 
 	write_lock_bh(&ksocknal_data.ksnd_global_lock);
-        ksocknal_data.ksnd_nthreads++;
+	ksocknal_data.ksnd_nthreads++;
 	write_unlock_bh(&ksocknal_data.ksnd_global_lock);
-        return (0);
+	return 0;
 }
 
 void
@@ -1396,22 +1396,17 @@ int ksocknal_scheduler(void *arg)
 	ksock_tx_t		*tx;
 	int			rc;
 	int			nloops = 0;
-	char			name[20];
 	long			id = (long)arg;
 
 	info = ksocknal_data.ksnd_sched_info[KSOCK_THREAD_CPT(id)];
 	sched = &info->ksi_scheds[KSOCK_THREAD_SID(id)];
 
-	snprintf(name, sizeof(name), "socknal_sd%02d_%02d",
-		 info->ksi_cpt, (int)(sched - &info->ksi_scheds[0]));
-
-	cfs_daemonize(name);
 	cfs_block_allsigs();
 
 	rc = cfs_cpt_bind(lnet_cpt_table(), info->ksi_cpt);
 	if (rc != 0) {
-		CERROR("Can't set CPT affinity for %s to %d: %d\n",
-		       name, info->ksi_cpt, rc);
+		CERROR("Can't set CPT affinity to %d: %d\n",
+		       info->ksi_cpt, rc);
 	}
 
 	spin_lock_bh(&sched->kss_lock);
@@ -2023,6 +2018,7 @@ ksocknal_connect (ksock_route_t *route)
 static int
 ksocknal_connd_check_start(long sec, long *timeout)
 {
+	char name[16];
         int rc;
         int total = ksocknal_data.ksnd_connd_starting +
                     ksocknal_data.ksnd_connd_running;
@@ -2060,7 +2056,8 @@ ksocknal_connd_check_start(long sec, long *timeout)
 	spin_unlock_bh(&ksocknal_data.ksnd_connd_lock);
 
 	/* NB: total is the next id */
-	rc = ksocknal_thread_start(ksocknal_connd, (void *)((long)total));
+	snprintf(name, sizeof(name), "socknal_cd%02d", total);
+	rc = ksocknal_thread_start(ksocknal_connd, NULL, name);
 
 	spin_lock_bh(&ksocknal_data.ksnd_connd_lock);
         if (rc == 0)
@@ -2145,15 +2142,11 @@ int
 ksocknal_connd (void *arg)
 {
 	spinlock_t    *connd_lock = &ksocknal_data.ksnd_connd_lock;
-        long               id = (long)(long_ptr_t)arg;
-        char               name[16];
         ksock_connreq_t   *cr;
         cfs_waitlink_t     wait;
         int                nloops = 0;
         int                cons_retry = 0;
 
-        snprintf (name, sizeof (name), "socknal_cd%02ld", id);
-        cfs_daemonize (name);
         cfs_block_allsigs ();
 
         cfs_waitlink_init (&wait);
@@ -2546,7 +2539,6 @@ ksocknal_reaper (void *arg)
         int                peer_index = 0;
         cfs_time_t         deadline = cfs_time_current();
 
-        cfs_daemonize ("socknal_reaper");
         cfs_block_allsigs ();
 
         CFS_INIT_LIST_HEAD(&enomem_conns);
diff --git a/lnet/lnet/acceptor.c b/lnet/lnet/acceptor.c
index 9e9b236..9bdac05 100644
--- a/lnet/lnet/acceptor.c
+++ b/lnet/lnet/acceptor.c
@@ -389,7 +389,6 @@ lnet_accept(cfs_socket_t *sock, __u32 magic)
 int
 lnet_acceptor(void *arg)
 {
-        char           name[16];
         cfs_socket_t  *newsock;
         int            rc;
         __u32          magic;
@@ -399,8 +398,6 @@ lnet_acceptor(void *arg)
 
         LASSERT (lnet_acceptor_state.pta_sock == NULL);
 
-        snprintf(name, sizeof(name), "acceptor_%03d", accept_port);
-        cfs_daemonize(name);
         cfs_block_allsigs();
 
         rc = libcfs_sock_listen(&lnet_acceptor_state.pta_sock,
@@ -532,9 +529,11 @@ lnet_acceptor_start(void)
 	if (lnet_count_acceptor_nis() == 0)  /* not required */
 		return 0;
 
-	rc2 = cfs_create_thread(lnet_acceptor, (void *)(ulong_ptr_t)secure, 0);
-	if (rc2 < 0) {
-		CERROR("Can't start acceptor thread: %d\n", rc);
+	rc2 = PTR_ERR(kthread_run(lnet_acceptor,
+				  (void *)(ulong_ptr_t)secure,
+				  "acceptor_%03ld", secure));
+	if (IS_ERR_VALUE(rc2)) {
+		CERROR("Can't start acceptor thread: %ld\n", rc2);
 		fini_completion(&lnet_acceptor_state.pta_signal);
 
 		return -ESRCH;
diff --git a/lnet/lnet/module.c b/lnet/lnet/module.c
index 770345d..9d57479 100644
--- a/lnet/lnet/module.c
+++ b/lnet/lnet/module.c
@@ -127,11 +127,11 @@ init_lnet(void)
         rc = libcfs_register_ioctl(&lnet_ioctl_handler);
         LASSERT (rc == 0);
 
-        if (config_on_load) {
-                /* Have to schedule a separate thread to avoid deadlocking
-                 * in modload */
-                (void) cfs_create_thread(lnet_configure, NULL, 0);
-        }
+	if (config_on_load) {
+		/* Have to schedule a separate thread to avoid deadlocking
+		 * in modload */
+		(void) kthread_run(lnet_configure, NULL, "lnet_initd");
+	}
 
         RETURN(0);
 }
diff --git a/lnet/lnet/router.c b/lnet/lnet/router.c
index 80c0a59..50495a6 100644
--- a/lnet/lnet/router.c
+++ b/lnet/lnet/router.c
@@ -1095,16 +1095,17 @@ lnet_router_checker_start(void)
 
         the_lnet.ln_rc_state = LNET_RC_STATE_RUNNING;
 #ifdef __KERNEL__
-        rc = cfs_create_thread(lnet_router_checker, NULL, 0);
-        if (rc < 0) {
-                CERROR("Can't start router checker thread: %d\n", rc);
-                /* block until event callback signals exit */
+	rc = PTR_ERR(kthread_run(lnet_router_checker,
+				 NULL, "router_checker"));
+	if (IS_ERR_VALUE(rc)) {
+		CERROR("Can't start router checker thread: %d\n", rc);
+		/* block until event callback signals exit */
 		down(&the_lnet.ln_rc_signal);
-                rc = LNetEQFree(the_lnet.ln_rc_eqh);
-                LASSERT (rc == 0);
-                the_lnet.ln_rc_state = LNET_RC_STATE_SHUTDOWN;
-                return -ENOMEM;
-        }
+		rc = LNetEQFree(the_lnet.ln_rc_eqh);
+		LASSERT(rc == 0);
+		the_lnet.ln_rc_state = LNET_RC_STATE_SHUTDOWN;
+		return -ENOMEM;
+	}
 #endif
 
         if (check_routers_before_use) {
@@ -1230,7 +1231,6 @@ lnet_router_checker(void *arg)
         lnet_peer_t       *rtr;
         cfs_list_t        *entry;
 
-        cfs_daemonize("router_checker");
         cfs_block_allsigs();
 
         LASSERT (the_lnet.ln_rc_state == LNET_RC_STATE_RUNNING);
diff --git a/lnet/selftest/timer.c b/lnet/selftest/timer.c
index a66a336..f2f8262 100644
--- a/lnet/selftest/timer.c
+++ b/lnet/selftest/timer.c
@@ -183,7 +183,6 @@ stt_timer_main (void *arg)
 
         SET_BUT_UNUSED(rc);
 
-        cfs_daemonize("st_timer");
         cfs_block_allsigs();
 
         while (!stt_data.stt_shuttingdown) {
@@ -204,13 +203,13 @@ stt_timer_main (void *arg)
 int
 stt_start_timer_thread (void)
 {
-        long pid;
+	cfs_task_t *task;
 
-        LASSERT (!stt_data.stt_shuttingdown);
+	LASSERT(!stt_data.stt_shuttingdown);
 
-        pid = cfs_create_thread(stt_timer_main, NULL, 0);
-        if (pid < 0)
-                return (int)pid;
+	task = kthread_run(stt_timer_main, NULL, "st_timer");
+	if (IS_ERR(task))
+		return PTR_ERR(task);
 
 	spin_lock(&stt_data.stt_lock);
 	stt_data.stt_nthreads++;
diff --git a/lnet/ulnds/socklnd/usocklnd.c b/lnet/ulnds/socklnd/usocklnd.c
index cc8c4c8..d4d5027 100644
--- a/lnet/ulnds/socklnd/usocklnd.c
+++ b/lnet/ulnds/socklnd/usocklnd.c
@@ -296,14 +296,15 @@ usocklnd_base_startup()
         pthread_rwlock_init(&usock_data.ud_peers_lock, NULL);
 
         /* Spawn poll threads */
-        for (i = 0; i < usock_data.ud_npollthreads; i++) {
-                rc = cfs_create_thread(usocklnd_poll_thread,
-                                       &usock_data.ud_pollthreads[i], 0);
-                if (rc) {
-                        usocklnd_base_shutdown(i);
-                        return rc;
-                }
-        }
+	for (i = 0; i < usock_data.ud_npollthreads; i++) {
+		rc = PTR_ERR(kthread_run(usocklnd_poll_thread,
+					     &usock_data.ud_pollthreads[i],
+					     ""));
+		if (IS_ERR_VALUE(rc)) {
+			usocklnd_base_shutdown(i);
+			return rc;
+		}
+	}
 
         usock_data.ud_state = UD_STATE_INITIALIZED;
 
diff --git a/lustre/ldlm/ldlm_lib.c b/lustre/ldlm/ldlm_lib.c
index 2e3a1d5..e61583a 100644
--- a/lustre/ldlm/ldlm_lib.c
+++ b/lustre/ldlm/ldlm_lib.c
@@ -1975,19 +1975,12 @@ static int target_recovery_thread(void *arg)
         struct ptlrpc_request *req;
         struct target_recovery_data *trd = &obd->obd_recovery_data;
         unsigned long delta;
-        unsigned long flags;
         struct lu_env *env;
         struct ptlrpc_thread *thread = NULL;
         int rc = 0;
         ENTRY;
 
-        cfs_daemonize_ctxt("tgt_recov");
-
-        SIGNAL_MASK_LOCK(current, flags);
-        sigfillset(&current->blocked);
-        RECALC_SIGPENDING;
-        SIGNAL_MASK_UNLOCK(current, flags);
-
+	unshare_fs_struct();
         OBD_ALLOC_PTR(thread);
         if (thread == NULL)
                 RETURN(-ENOMEM);
@@ -2112,22 +2105,24 @@ static int target_recovery_thread(void *arg)
 static int target_start_recovery_thread(struct lu_target *lut,
                                         svc_handler_t handler)
 {
-        struct obd_device *obd = lut->lut_obd;
-        int rc = 0;
-        struct target_recovery_data *trd = &obd->obd_recovery_data;
+	struct obd_device *obd = lut->lut_obd;
+	int rc = 0;
+	struct target_recovery_data *trd = &obd->obd_recovery_data;
 
-        memset(trd, 0, sizeof(*trd));
+	memset(trd, 0, sizeof(*trd));
 	init_completion(&trd->trd_starting);
 	init_completion(&trd->trd_finishing);
-        trd->trd_recovery_handler = handler;
+	trd->trd_recovery_handler = handler;
 
-        if (cfs_create_thread(target_recovery_thread, lut, 0) > 0) {
+	if (!IS_ERR(kthread_run(target_recovery_thread,
+				lut, "tgt_recov"))) {
 		wait_for_completion(&trd->trd_starting);
-                LASSERT(obd->obd_recovering != 0);
-        } else
-                rc = -ECHILD;
+		LASSERT(obd->obd_recovering != 0);
+	} else {
+		rc = -ECHILD;
+	}
 
-        return rc;
+	return rc;
 }
 
 void target_stop_recovery_thread(struct obd_device *obd)
diff --git a/lustre/ldlm/ldlm_lockd.c b/lustre/ldlm/ldlm_lockd.c
index 31925ff..3a9bf14 100644
--- a/lustre/ldlm/ldlm_lockd.c
+++ b/lustre/ldlm/ldlm_lockd.c
@@ -178,7 +178,6 @@ static int expired_lock_main(void *arg)
         int do_dump;
 
         ENTRY;
-        cfs_daemonize("ldlm_elt");
 
         expired_lock_thread.elt_state = ELT_READY;
         cfs_waitq_signal(&expired_lock_thread.elt_waitq);
@@ -2570,14 +2569,17 @@ static int ldlm_bl_thread_main(void *arg);
 static int ldlm_bl_thread_start(struct ldlm_bl_pool *blp)
 {
 	struct ldlm_bl_thread_data bltd = { .bltd_blp = blp };
-	int rc;
+	cfs_task_t *task;
 
 	init_completion(&bltd.bltd_comp);
-	rc = cfs_create_thread(ldlm_bl_thread_main, &bltd, 0);
-	if (rc < 0) {
-		CERROR("cannot start LDLM thread ldlm_bl_%02d: rc %d\n",
-		       cfs_atomic_read(&blp->blp_num_threads), rc);
-		return rc;
+	bltd.bltd_num = cfs_atomic_read(&blp->blp_num_threads);
+	snprintf(bltd.bltd_name, sizeof(bltd.bltd_name) - 1,
+		"ldlm_bl_%02d", bltd.bltd_num);
+	task = kthread_run(ldlm_bl_thread_main, &bltd, bltd.bltd_name);
+	if (IS_ERR(task)) {
+		CERROR("cannot start LDLM thread ldlm_bl_%02d: rc %ld\n",
+		       cfs_atomic_read(&blp->blp_num_threads), PTR_ERR(task));
+		return PTR_ERR(task);
 	}
 	wait_for_completion(&bltd.bltd_comp);
 
@@ -2601,14 +2603,9 @@ static int ldlm_bl_thread_main(void *arg)
 
                 blp = bltd->bltd_blp;
 
-                bltd->bltd_num =
-                        cfs_atomic_inc_return(&blp->blp_num_threads) - 1;
+		cfs_atomic_inc(&blp->blp_num_threads);
                 cfs_atomic_inc(&blp->blp_busy_threads);
 
-                snprintf(bltd->bltd_name, sizeof(bltd->bltd_name) - 1,
-                        "ldlm_bl_%02d", bltd->bltd_num);
-                cfs_daemonize(bltd->bltd_name);
-
 		complete(&bltd->bltd_comp);
                 /* cannot use bltd after this, it is only on caller's stack */
         }
@@ -2948,22 +2945,22 @@ static int ldlm_setup(void)
 	}
 
 # ifdef HAVE_SERVER_SUPPORT
-        CFS_INIT_LIST_HEAD(&expired_lock_thread.elt_expired_locks);
-        expired_lock_thread.elt_state = ELT_STOPPED;
-        cfs_waitq_init(&expired_lock_thread.elt_waitq);
+	CFS_INIT_LIST_HEAD(&expired_lock_thread.elt_expired_locks);
+	expired_lock_thread.elt_state = ELT_STOPPED;
+	cfs_waitq_init(&expired_lock_thread.elt_waitq);
 
-        CFS_INIT_LIST_HEAD(&waiting_locks_list);
+	CFS_INIT_LIST_HEAD(&waiting_locks_list);
 	spin_lock_init(&waiting_locks_spinlock);
-        cfs_timer_init(&waiting_locks_timer, waiting_locks_callback, 0);
+	cfs_timer_init(&waiting_locks_timer, waiting_locks_callback, 0);
 
-        rc = cfs_create_thread(expired_lock_main, NULL, CFS_DAEMON_FLAGS);
-	if (rc < 0) {
+	rc = PTR_ERR(kthread_run(expired_lock_main, NULL, "ldlm_elt"));
+	if (IS_ERR_VALUE(rc)) {
 		CERROR("Cannot start ldlm expired-lock thread: %d\n", rc);
 		GOTO(out, rc);
 	}
 
-        cfs_wait_event(expired_lock_thread.elt_waitq,
-                       expired_lock_thread.elt_state == ELT_READY);
+	cfs_wait_event(expired_lock_thread.elt_waitq,
+		       expired_lock_thread.elt_state == ELT_READY);
 # endif /* HAVE_SERVER_SUPPORT */
 
 	rc = ldlm_pools_init();
diff --git a/lustre/ldlm/ldlm_pool.c b/lustre/ldlm/ldlm_pool.c
index d724a2d..fa14f66 100644
--- a/lustre/ldlm/ldlm_pool.c
+++ b/lustre/ldlm/ldlm_pool.c
@@ -1295,15 +1295,13 @@ EXPORT_SYMBOL(ldlm_pools_recalc);
 static int ldlm_pools_thread_main(void *arg)
 {
         struct ptlrpc_thread *thread = (struct ptlrpc_thread *)arg;
-        char *t_name = "ldlm_poold";
         ENTRY;
 
-        cfs_daemonize(t_name);
         thread_set_flags(thread, SVC_RUNNING);
         cfs_waitq_signal(&thread->t_ctl_waitq);
 
         CDEBUG(D_DLMTRACE, "%s: pool thread starting, process %d\n",
-               t_name, cfs_curproc_pid());
+		"ldlm_poold", cfs_curproc_pid());
 
         while (1) {
                 struct l_wait_info lwi;
@@ -1335,43 +1333,38 @@ static int ldlm_pools_thread_main(void *arg)
         cfs_waitq_signal(&thread->t_ctl_waitq);
 
         CDEBUG(D_DLMTRACE, "%s: pool thread exiting, process %d\n",
-               t_name, cfs_curproc_pid());
+		"ldlm_poold", cfs_curproc_pid());
 
 	complete_and_exit(&ldlm_pools_comp, 0);
 }
 
 static int ldlm_pools_thread_start(void)
 {
-        struct l_wait_info lwi = { 0 };
-        int rc;
-        ENTRY;
+	struct l_wait_info lwi = { 0 };
+	cfs_task_t *task;
+	ENTRY;
 
-        if (ldlm_pools_thread != NULL)
-                RETURN(-EALREADY);
+	if (ldlm_pools_thread != NULL)
+		RETURN(-EALREADY);
 
-        OBD_ALLOC_PTR(ldlm_pools_thread);
-        if (ldlm_pools_thread == NULL)
-                RETURN(-ENOMEM);
+	OBD_ALLOC_PTR(ldlm_pools_thread);
+	if (ldlm_pools_thread == NULL)
+		RETURN(-ENOMEM);
 
 	init_completion(&ldlm_pools_comp);
-        cfs_waitq_init(&ldlm_pools_thread->t_ctl_waitq);
-
-        /*
-         * CLONE_VM and CLONE_FILES just avoid a needless copy, because we
-         * just drop the VM and FILES in cfs_daemonize() right away.
-         */
-        rc = cfs_create_thread(ldlm_pools_thread_main, ldlm_pools_thread,
-                               CFS_DAEMON_FLAGS);
-        if (rc < 0) {
-                CERROR("Can't start pool thread, error %d\n",
-                       rc);
-                OBD_FREE(ldlm_pools_thread, sizeof(*ldlm_pools_thread));
-                ldlm_pools_thread = NULL;
-                RETURN(rc);
-        }
-        l_wait_event(ldlm_pools_thread->t_ctl_waitq,
-                     thread_is_running(ldlm_pools_thread), &lwi);
-        RETURN(0);
+	cfs_waitq_init(&ldlm_pools_thread->t_ctl_waitq);
+
+	task = kthread_run(ldlm_pools_thread_main, ldlm_pools_thread,
+			   "ldlm_poold");
+	if (IS_ERR(task)) {
+		CERROR("Can't start pool thread, error %ld\n", PTR_ERR(task));
+		OBD_FREE(ldlm_pools_thread, sizeof(*ldlm_pools_thread));
+		ldlm_pools_thread = NULL;
+		RETURN(PTR_ERR(task));
+	}
+	l_wait_event(ldlm_pools_thread->t_ctl_waitq,
+		     thread_is_running(ldlm_pools_thread), &lwi);
+	RETURN(0);
 }
 
 static void ldlm_pools_thread_stop(void)
diff --git a/lustre/llite/llite_capa.c b/lustre/llite/llite_capa.c
index 1d489e6..5e269b3 100644
--- a/lustre/llite/llite_capa.c
+++ b/lustre/llite/llite_capa.c
@@ -173,8 +173,6 @@ static int capa_thread_main(void *unused)
         int rc;
         ENTRY;
 
-        cfs_daemonize("ll_capa");
-
         thread_set_flags(&ll_capa_thread, SVC_RUNNING);
         cfs_waitq_signal(&ll_capa_thread.t_ctl_waitq);
 
@@ -293,20 +291,21 @@ void ll_capa_timer_callback(unsigned long unused)
 
 int ll_capa_thread_start(void)
 {
-        int rc;
-        ENTRY;
+	cfs_task_t *task;
+	ENTRY;
 
-        cfs_waitq_init(&ll_capa_thread.t_ctl_waitq);
+	cfs_waitq_init(&ll_capa_thread.t_ctl_waitq);
 
-        rc = cfs_create_thread(capa_thread_main, NULL, 0);
-        if (rc < 0) {
-                CERROR("cannot start expired capa thread: rc %d\n", rc);
-                RETURN(rc);
-        }
-        cfs_wait_event(ll_capa_thread.t_ctl_waitq,
-                       thread_is_running(&ll_capa_thread));
+	task = kthread_run(capa_thread_main, NULL, "ll_capa");
+	if (IS_ERR(task)) {
+		CERROR("cannot start expired capa thread: rc %ld\n",
+			PTR_ERR(task));
+		RETURN(PTR_ERR(task));
+	}
+	cfs_wait_event(ll_capa_thread.t_ctl_waitq,
+		       thread_is_running(&ll_capa_thread));
 
-        RETURN(0);
+	RETURN(0);
 }
 
 void ll_capa_thread_stop(void)
diff --git a/lustre/llite/llite_close.c b/lustre/llite/llite_close.c
index 26a2c8c..f1a1415 100644
--- a/lustre/llite/llite_close.c
+++ b/lustre/llite/llite_close.c
@@ -349,12 +349,6 @@ static int ll_close_thread(void *arg)
         struct ll_close_queue *lcq = arg;
         ENTRY;
 
-        {
-                char name[CFS_CURPROC_COMM_MAX];
-                snprintf(name, sizeof(name) - 1, "ll_close");
-                cfs_daemonize(name);
-        }
-
 	complete(&lcq->lcq_comp);
 
         while (1) {
@@ -382,25 +376,25 @@ static int ll_close_thread(void *arg)
 
 int ll_close_thread_start(struct ll_close_queue **lcq_ret)
 {
-        struct ll_close_queue *lcq;
-        pid_t pid;
+	struct ll_close_queue *lcq;
+	cfs_task_t *task;
 
-        if (OBD_FAIL_CHECK(OBD_FAIL_LDLM_CLOSE_THREAD))
-                return -EINTR;
+	if (OBD_FAIL_CHECK(OBD_FAIL_LDLM_CLOSE_THREAD))
+		return -EINTR;
 
-        OBD_ALLOC(lcq, sizeof(*lcq));
-        if (lcq == NULL)
-                return -ENOMEM;
+	OBD_ALLOC(lcq, sizeof(*lcq));
+	if (lcq == NULL)
+		return -ENOMEM;
 
 	spin_lock_init(&lcq->lcq_lock);
 	CFS_INIT_LIST_HEAD(&lcq->lcq_head);
 	cfs_waitq_init(&lcq->lcq_waitq);
 	init_completion(&lcq->lcq_comp);
 
-	pid = cfs_create_thread(ll_close_thread, lcq, 0);
-	if (pid < 0) {
+	task = kthread_run(ll_close_thread, lcq, "ll_close");
+	if (IS_ERR(task)) {
 		OBD_FREE(lcq, sizeof(*lcq));
-		return pid;
+		return PTR_ERR(task);
 	}
 
 	wait_for_completion(&lcq->lcq_comp);
diff --git a/lustre/llite/lloop.c b/lustre/llite/lloop.c
index 4c58181..1d4e2e8 100644
--- a/lustre/llite/lloop.c
+++ b/lustre/llite/lloop.c
@@ -420,8 +420,6 @@ static int loop_thread(void *data)
         int refcheck;
         int ret = 0;
 
-        daemonize("lloop%d", lo->lo_number);
-
         set_user_nice(current, -20);
 
         lo->lo_state = LLOOP_BOUND;
@@ -552,13 +550,13 @@ static int loop_set_fd(struct lloop_device *lo, struct file *unused,
         set_capacity(disks[lo->lo_number], size);
         bd_set_size(bdev, size << 9);
 
-        set_blocksize(bdev, lo->lo_blocksize);
+	set_blocksize(bdev, lo->lo_blocksize);
 
-        cfs_create_thread(loop_thread, lo, CLONE_KERNEL);
+	kthread_run(loop_thread, lo, "lloop%d", lo->lo_number);
 	down(&lo->lo_sem);
-        return 0;
+	return 0;
 
- out:
+out:
         /* This is safe: open() is still holding a reference. */
         cfs_module_put(THIS_MODULE);
         return error;
diff --git a/lustre/llite/statahead.c b/lustre/llite/statahead.c
index 6d5b7af..3211557 100644
--- a/lustre/llite/statahead.c
+++ b/lustre/llite/statahead.c
@@ -981,12 +981,6 @@ static int ll_agl_thread(void *arg)
         struct l_wait_info        lwi    = { 0 };
         ENTRY;
 
-        {
-                char pname[16];
-                snprintf(pname, 15, "ll_agl_%u", plli->lli_opendir_pid);
-                cfs_daemonize(pname);
-        }
-
         CDEBUG(D_READA, "agl thread started: [pid %d] [parent %.*s]\n",
                cfs_curproc_pid(), parent->d_name.len, parent->d_name.name);
 
@@ -1040,25 +1034,28 @@ static int ll_agl_thread(void *arg)
 
 static void ll_start_agl(struct dentry *parent, struct ll_statahead_info *sai)
 {
-        struct ptlrpc_thread *thread = &sai->sai_agl_thread;
-        struct l_wait_info    lwi    = { 0 };
-        int                   rc;
-        ENTRY;
+	struct ptlrpc_thread *thread = &sai->sai_agl_thread;
+	struct l_wait_info    lwi    = { 0 };
+	struct ll_inode_info  *plli;
+	cfs_task_t	      *task;
+	ENTRY;
 
-        CDEBUG(D_READA, "start agl thread: [pid %d] [parent %.*s]\n",
-               cfs_curproc_pid(), parent->d_name.len, parent->d_name.name);
+	CDEBUG(D_READA, "start agl thread: [pid %d] [parent %.*s]\n",
+	       cfs_curproc_pid(), parent->d_name.len, parent->d_name.name);
 
-        rc = cfs_create_thread(ll_agl_thread, parent, 0);
-        if (rc < 0) {
-                CERROR("can't start ll_agl thread, rc: %d\n", rc);
-                thread_set_flags(thread, SVC_STOPPED);
-                RETURN_EXIT;
-        }
+	plli = ll_i2info(parent->d_inode);
+	task = kthread_run(ll_agl_thread, parent,
+			       "ll_agl_%u", plli->lli_opendir_pid);
+	if (IS_ERR(task)) {
+		CERROR("can't start ll_agl thread, rc: %ld\n", PTR_ERR(task));
+		thread_set_flags(thread, SVC_STOPPED);
+		RETURN_EXIT;
+	}
 
-        l_wait_event(thread->t_ctl_waitq,
-                     thread_is_running(thread) || thread_is_stopped(thread),
-                     &lwi);
-        EXIT;
+	l_wait_event(thread->t_ctl_waitq,
+		     thread_is_running(thread) || thread_is_stopped(thread),
+		     &lwi);
+	EXIT;
 }
 
 static int ll_statahead_thread(void *arg)
@@ -1079,12 +1076,6 @@ static int ll_statahead_thread(void *arg)
         struct l_wait_info        lwi    = { 0 };
         ENTRY;
 
-        {
-                char pname[16];
-                snprintf(pname, 15, "ll_sa_%u", plli->lli_opendir_pid);
-                cfs_daemonize(pname);
-        }
-
         CDEBUG(D_READA, "statahead thread started: [pid %d] [parent %.*s]\n",
                cfs_curproc_pid(), parent->d_name.len, parent->d_name.name);
 
@@ -1548,6 +1539,7 @@ int do_statahead_enter(struct inode *dir, struct dentry **dentryp,
         struct ptlrpc_thread     *thread;
         struct l_wait_info        lwi   = { 0 };
         int                       rc    = 0;
+	struct ll_inode_info     *plli;
         ENTRY;
 
         LASSERT(lli->lli_opendir_pid == cfs_curproc_pid());
@@ -1693,11 +1685,14 @@ int do_statahead_enter(struct inode *dir, struct dentry **dentryp,
                cfs_curproc_pid(), parent->d_name.len, parent->d_name.name);
 
         lli->lli_sai = sai;
-        rc = cfs_create_thread(ll_statahead_thread, parent, 0);
-        thread = &sai->sai_thread;
-        if (rc < 0) {
-                CERROR("can't start ll_sa thread, rc: %d\n", rc);
-                dput(parent);
+
+	plli = ll_i2info(parent->d_inode);
+	rc = PTR_ERR(kthread_run(ll_statahead_thread, parent,
+				 "ll_sa_%u", plli->lli_opendir_pid));
+	thread = &sai->sai_thread;
+	if (IS_ERR_VALUE(rc)) {
+		CERROR("can't start ll_sa thread, rc: %d\n", rc);
+		dput(parent);
                 lli->lli_opendir_key = NULL;
                 thread_set_flags(thread, SVC_STOPPED);
                 thread_set_flags(&sai->sai_agl_thread, SVC_STOPPED);
diff --git a/lustre/mdc/mdc_request.c b/lustre/mdc/mdc_request.c
index c9aa7a0..ead4bcf 100644
--- a/lustre/mdc/mdc_request.c
+++ b/lustre/mdc/mdc_request.c
@@ -1566,13 +1566,6 @@ static int mdc_changelog_send_thread(void *csdata)
         CDEBUG(D_CHANGELOG, "changelog to fp=%p start "LPU64"\n",
                cs->cs_fp, cs->cs_startrec);
 
-        /*
-         * It's important to daemonize here to close unused FDs.
-         * The write fd from pipe is already opened by the caller,
-         * so it's fine to clear all files here
-         */
-        cfs_daemonize("mdc_clg_send_thread");
-
         OBD_ALLOC(cs->cs_buf, CR_MAXSIZE);
         if (cs->cs_buf == NULL)
                 GOTO(out, rc = -ENOMEM);
@@ -1609,12 +1602,10 @@ out:
 		llog_cat_close(NULL, llh);
         if (ctxt)
                 llog_ctxt_put(ctxt);
-        if (cs->cs_buf)
-                OBD_FREE(cs->cs_buf, CR_MAXSIZE);
-        OBD_FREE_PTR(cs);
-        /* detach from parent process so we get cleaned up */
-        cfs_daemonize("cl_send");
-        return rc;
+	if (cs->cs_buf)
+		OBD_FREE(cs->cs_buf, CR_MAXSIZE);
+	OBD_FREE_PTR(cs);
+	return rc;
 }
 
 static int mdc_ioc_changelog_send(struct obd_device *obd,
@@ -1634,13 +1625,16 @@ static int mdc_ioc_changelog_send(struct obd_device *obd,
 	cs->cs_fp = fget(icc->icc_id);
 	cs->cs_flags = icc->icc_flags;
 
-        /* New thread because we should return to user app before
-           writing into our pipe */
-        rc = cfs_create_thread(mdc_changelog_send_thread, cs, CFS_DAEMON_FLAGS);
-        if (rc >= 0) {
-                CDEBUG(D_CHANGELOG, "start changelog thread: %d\n", rc);
-                return 0;
-        }
+	/*
+	 * New thread because we should return to user app before
+	 * writing into our pipe
+	 */
+        rc = PTR_ERR(kthread_run(mdc_changelog_send_thread, cs,
+				 "mdc_clg_send_thread"));
+	if (!IS_ERR_VALUE(rc)) {
+		CDEBUG(D_CHANGELOG, "start changelog thread\n");
+		return 0;
+	}
 
         CERROR("Failed to start changelog thread: %d\n", rc);
         OBD_FREE_PTR(cs);
diff --git a/lustre/mdd/mdd_lfsck.c b/lustre/mdd/mdd_lfsck.c
index 9d7b54c..7ced9dd 100644
--- a/lustre/mdd/mdd_lfsck.c
+++ b/lustre/mdd/mdd_lfsck.c
@@ -2525,8 +2525,7 @@ static int mdd_lfsck_main(void *args)
 	int			 rc;
 	ENTRY;
 
-	cfs_daemonize("lfsck");
-	rc = lu_env_init(&env, LCT_MD_THREAD);
+	rc = lu_env_init(&env, LCT_MD_THREAD | LCT_DT_THREAD);
 	if (rc != 0) {
 		CERROR("%s: LFSCK, fail to init env, rc = %d\n",
 		       mdd_lfsck2name(lfsck), rc);
@@ -2789,8 +2788,8 @@ trigger:
 
 	lfsck->ml_args_oit = (flags << DT_OTABLE_IT_FLAGS_SHIFT) | valid;
 	thread_set_flags(thread, 0);
-	rc = cfs_create_thread(mdd_lfsck_main, lfsck, 0);
-	if (rc < 0)
+	rc = PTR_ERR(kthread_run(mdd_lfsck_main, lfsck, "lfsck"));
+	if (IS_ERR_VALUE(rc))
 		CERROR("%s: cannot start LFSCK thread, rc = %d\n",
 		       mdd_lfsck2name(lfsck), rc);
 	else
diff --git a/lustre/mdt/mdt_capa.c b/lustre/mdt/mdt_capa.c
index 76e2c6f..d4a8bc4 100644
--- a/lustre/mdt/mdt_capa.c
+++ b/lustre/mdt/mdt_capa.c
@@ -218,7 +218,7 @@ static int mdt_ck_thread_main(void *args)
         int                     rc;
         ENTRY;
 
-        cfs_daemonize_ctxt("mdt_ck");
+	unshare_fs_struct();
         cfs_block_allsigs();
 
         thread_set_flags(thread, SVC_RUNNING);
@@ -290,18 +290,18 @@ static int mdt_ck_thread_main(void *args)
 
 int mdt_ck_thread_start(struct mdt_device *mdt)
 {
-        struct ptlrpc_thread *thread = &mdt->mdt_ck_thread;
-        int rc;
-
-        cfs_waitq_init(&thread->t_ctl_waitq);
-        rc = cfs_create_thread(mdt_ck_thread_main, mdt, CFS_DAEMON_FLAGS);
-        if (rc < 0) {
-                CERROR("cannot start mdt_ck thread, rc = %d\n", rc);
-                return rc;
-        }
-
-        l_wait_condition(thread->t_ctl_waitq, thread_is_running(thread));
-        return 0;
+	struct ptlrpc_thread *thread = &mdt->mdt_ck_thread;
+	cfs_task_t *task;
+
+	cfs_waitq_init(&thread->t_ctl_waitq);
+	task = kthread_run(mdt_ck_thread_main, mdt, "mdt_ck");
+	if (IS_ERR(task)) {
+		CERROR("cannot start mdt_ck thread, rc = %ld\n", PTR_ERR(task));
+		return PTR_ERR(task);
+	}
+
+	l_wait_condition(thread->t_ctl_waitq, thread_is_running(thread));
+	return 0;
 }
 
 void mdt_ck_thread_stop(struct mdt_device *mdt)
diff --git a/lustre/mgc/mgc_request.c b/lustre/mgc/mgc_request.c
index 6b84a29..f7e6514 100644
--- a/lustre/mgc/mgc_request.c
+++ b/lustre/mgc/mgc_request.c
@@ -480,12 +480,9 @@ static void do_requeue(struct config_llog_data *cld)
 
 static int mgc_requeue_thread(void *data)
 {
-        char name[] = "ll_cfg_requeue";
         int rc = 0;
         ENTRY;
 
-        cfs_daemonize(name);
-
         CDEBUG(D_MGC, "Starting requeue thread\n");
 
         /* Keep trying failed locks periodically */
@@ -776,20 +773,20 @@ static int mgc_setup(struct obd_device *obd, struct lustre_cfg *lcfg)
         sptlrpc_lprocfs_cliobd_attach(obd);
 
         if (cfs_atomic_inc_return(&mgc_count) == 1) {
-                rq_state = 0;
-                cfs_waitq_init(&rq_waitq);
-
-                /* start requeue thread */
-                rc = cfs_create_thread(mgc_requeue_thread, NULL,
-                                       CFS_DAEMON_FLAGS);
-                if (rc < 0) {
-                        CERROR("%s: Cannot start requeue thread (%d),"
-                               "no more log updates!\n",
-                               obd->obd_name, rc);
-                        GOTO(err_cleanup, rc);
-                }
-                /* rc is the pid of mgc_requeue_thread. */
-                rc = 0;
+		rq_state = 0;
+		cfs_waitq_init(&rq_waitq);
+
+		/* start requeue thread */
+		rc = PTR_ERR(kthread_run(mgc_requeue_thread, NULL,
+					     "ll_cfg_requeue"));
+		if (IS_ERR_VALUE(rc)) {
+			CERROR("%s: Cannot start requeue thread (%d),"
+			       "no more log updates!\n",
+			       obd->obd_name, rc);
+			GOTO(err_cleanup, rc);
+		}
+		/* rc is the pid of mgc_requeue_thread. */
+		rc = 0;
         }
 
         RETURN(rc);
diff --git a/lustre/mgs/mgs_nids.c b/lustre/mgs/mgs_nids.c
index 781250f..e6abdc4 100644
--- a/lustre/mgs/mgs_nids.c
+++ b/lustre/mgs/mgs_nids.c
@@ -440,7 +440,6 @@ static int mgs_ir_notify(void *arg)
 
         LASSERTF(sizeof(name) < 32, "name is too large to be in stack.\n");
         sprintf(name, "mgs_%s_notify", fsdb->fsdb_name);
-        cfs_daemonize(name);
 
 	complete(&fsdb->fsdb_notify_comp);
 
@@ -471,7 +470,7 @@ static int mgs_ir_notify(void *arg)
 int mgs_ir_init_fs(const struct lu_env *env, struct mgs_device *mgs,
 		   struct fs_db *fsdb)
 {
-        int rc;
+	cfs_task_t *task;
 
         if (!ir_timeout)
                 ir_timeout = OBD_IR_MGS_TIMEOUT;
@@ -488,11 +487,13 @@ int mgs_ir_init_fs(const struct lu_env *env, struct mgs_device *mgs,
         cfs_atomic_set(&fsdb->fsdb_notify_phase, 0);
         cfs_waitq_init(&fsdb->fsdb_notify_waitq);
 	init_completion(&fsdb->fsdb_notify_comp);
-        rc = cfs_create_thread(mgs_ir_notify, fsdb, CFS_DAEMON_FLAGS);
-        if (rc > 0)
+
+	task = kthread_run(mgs_ir_notify, fsdb,
+			       "mgs_%s_notify", fsdb->fsdb_name);
+	if (IS_ERR(task))
 		wait_for_completion(&fsdb->fsdb_notify_comp);
-        else
-                CERROR("Start notify thread error %d\n", rc);
+	else
+		CERROR("Start notify thread error %ld\n", PTR_ERR(task));
 
 	mgs_nidtbl_init_fs(env, fsdb);
         return 0;
diff --git a/lustre/obdclass/genops.c b/lustre/obdclass/genops.c
index 436aa4d..0e29783 100644
--- a/lustre/obdclass/genops.c
+++ b/lustre/obdclass/genops.c
@@ -1744,14 +1744,7 @@ EXPORT_SYMBOL(obd_zombie_barrier);
  */
 static int obd_zombie_impexp_thread(void *unused)
 {
-	int rc;
-
-	rc = cfs_daemonize_ctxt("obd_zombid");
-	if (rc != 0) {
-		complete(&obd_zombie_start);
-		RETURN(rc);
-	}
-
+	unshare_fs_struct();
 	complete(&obd_zombie_start);
 
 	obd_zombie_pid = cfs_curproc_pid();
@@ -1800,7 +1793,9 @@ int obd_zombie_impexp_kill(void *arg)
  */
 int obd_zombie_impexp_init(void)
 {
-	int rc;
+#ifdef __KERNEL__
+	cfs_task_t *task;
+#endif
 
 	CFS_INIT_LIST_HEAD(&obd_zombie_imports);
 	CFS_INIT_LIST_HEAD(&obd_zombie_exports);
@@ -1811,9 +1806,9 @@ int obd_zombie_impexp_init(void)
 	obd_zombie_pid = 0;
 
 #ifdef __KERNEL__
-	rc = cfs_create_thread(obd_zombie_impexp_thread, NULL, 0);
-	if (rc < 0)
-		RETURN(rc);
+	task = kthread_run(obd_zombie_impexp_thread, NULL, "obd_zombid");
+	if (IS_ERR(task))
+		RETURN(PTR_ERR(task));
 
 	wait_for_completion(&obd_zombie_start);
 #else
@@ -1825,9 +1820,8 @@ int obd_zombie_impexp_init(void)
         obd_zombie_impexp_idle_cb =
                 liblustre_register_idle_callback("obd_zombi_impexp_check",
                                                  &obd_zombie_impexp_check, NULL);
-        rc = 0;
 #endif
-        RETURN(rc);
+	RETURN(0);
 }
 /**
  * stop destroy zombie import/export thread
diff --git a/lustre/obdclass/llog.c b/lustre/obdclass/llog.c
index 62c496b..d85b048 100644
--- a/lustre/obdclass/llog.c
+++ b/lustre/obdclass/llog.c
@@ -438,7 +438,7 @@ static int llog_process_thread_daemonize(void *arg)
 	struct lu_env			 env;
 	int				 rc;
 
-	cfs_daemonize_ctxt("llog_process_thread");
+	unshare_fs_struct();
 
 	/* client env has no keys, tags is just 0 */
 	rc = lu_env_init(&env, LCT_LOCAL | LCT_MG_THREAD);
@@ -480,9 +480,9 @@ int llog_process_or_fork(const struct lu_env *env,
 		 * init the new one in llog_process_thread_daemonize. */
 		lpi->lpi_env = NULL;
 		init_completion(&lpi->lpi_completion);
-		rc = cfs_create_thread(llog_process_thread_daemonize, lpi,
-				       CFS_DAEMON_FLAGS);
-		if (rc < 0) {
+		rc = PTR_ERR(kthread_run(llog_process_thread_daemonize, lpi,
+					     "llog_process_thread"));
+		if (IS_ERR_VALUE(rc)) {
 			CERROR("%s: cannot start thread: rc = %d\n",
 			       loghandle->lgh_ctxt->loc_obd->obd_name, rc);
 			OBD_FREE_PTR(lpi);
diff --git a/lustre/osd-ldiskfs/osd_scrub.c b/lustre/osd-ldiskfs/osd_scrub.c
index 77acd9e..a9130be 100644
--- a/lustre/osd-ldiskfs/osd_scrub.c
+++ b/lustre/osd-ldiskfs/osd_scrub.c
@@ -979,7 +979,6 @@ static int osd_scrub_main(void *args)
 	int		      rc;
 	ENTRY;
 
-	cfs_daemonize("OI_scrub");
 	rc = lu_env_init(&env, LCT_DT_THREAD);
 	if (rc != 0) {
 		CERROR("%.16s: OI scrub, fail to init env, rc = %d\n",
@@ -1554,8 +1553,8 @@ again:
 
 	scrub->os_start_flags = flags;
 	thread_set_flags(thread, 0);
-	rc = cfs_create_thread(osd_scrub_main, dev, 0);
-	if (rc < 0) {
+	rc = PTR_ERR(kthread_run(osd_scrub_main, dev, "OI_scrub"));
+	if (IS_ERR_VALUE(rc)) {
 		CERROR("%.16s: cannot start iteration thread, rc = %d\n",
 		       LDISKFS_SB(osd_sb(dev))->s_es->s_volume_name, rc);
 		RETURN(rc);
diff --git a/lustre/osp/osp_precreate.c b/lustre/osp/osp_precreate.c
index 914f988..d0d2ede 100644
--- a/lustre/osp/osp_precreate.c
+++ b/lustre/osp/osp_precreate.c
@@ -872,15 +872,11 @@ static int osp_precreate_thread(void *_arg)
 	struct osp_device	*d = _arg;
 	struct ptlrpc_thread	*thread = &d->opd_pre_thread;
 	struct l_wait_info	 lwi = { 0 };
-	char			 pname[16];
 	struct lu_env		 env;
 	int			 rc;
 
 	ENTRY;
 
-	sprintf(pname, "osp-pre-%u", d->opd_index);
-	cfs_daemonize(pname);
-
 	rc = lu_env_init(&env, d->opd_dt_dev.dd_lu_dev.ld_type->ldt_ctx_tags);
 	if (rc) {
 		CERROR("%s: init env error: rc = %d\n", d->opd_obd->obd_name,
@@ -1251,7 +1247,7 @@ out:
 int osp_init_precreate(struct osp_device *d)
 {
 	struct l_wait_info	 lwi = { 0 };
-	int			 rc;
+	cfs_task_t		*task;
 
 	ENTRY;
 
@@ -1286,10 +1282,11 @@ int osp_init_precreate(struct osp_device *d)
 	/*
 	 * start thread handling precreation and statfs updates
 	 */
-	rc = cfs_create_thread(osp_precreate_thread, d, 0);
-	if (rc < 0) {
-		CERROR("can't start precreate thread %d\n", rc);
-		RETURN(rc);
+	task = kthread_run(osp_precreate_thread, d,
+			       "osp-pre-%u", d->opd_index);
+	if (IS_ERR(task)) {
+		CERROR("can't start precreate thread %ld\n", PTR_ERR(task));
+		RETURN(PTR_ERR(task));
 	}
 
 	l_wait_event(d->opd_pre_thread.t_ctl_waitq,
diff --git a/lustre/osp/osp_sync.c b/lustre/osp/osp_sync.c
index 4bc9d58..a6952ce 100644
--- a/lustre/osp/osp_sync.c
+++ b/lustre/osp/osp_sync.c
@@ -823,7 +823,6 @@ static int osp_sync_thread(void *_arg)
 	struct llog_handle	*llh;
 	struct lu_env		 env;
 	int			 rc, count;
-	char			 pname[16];
 
 	ENTRY;
 
@@ -834,9 +833,6 @@ static int osp_sync_thread(void *_arg)
 		RETURN(rc);
 	}
 
-	sprintf(pname, "osp-syn-%u", d->opd_index);
-	cfs_daemonize(pname);
-
 	spin_lock(&d->opd_syn_lock);
 	thread->t_flags = SVC_RUNNING;
 	spin_unlock(&d->opd_syn_lock);
@@ -1041,8 +1037,9 @@ int osp_sync_init(const struct lu_env *env, struct osp_device *d)
 	cfs_waitq_init(&d->opd_syn_thread.t_ctl_waitq);
 	CFS_INIT_LIST_HEAD(&d->opd_syn_committed_there);
 
-	rc = cfs_create_thread(osp_sync_thread, d, 0);
-	if (rc < 0) {
+	rc = PTR_ERR(kthread_run(osp_sync_thread, d,
+				 "osp-syn-%u", d->opd_index));
+	if (IS_ERR_VALUE(rc)) {
 		CERROR("%s: can't start sync thread: rc = %d\n",
 		       d->opd_obd->obd_name, rc);
 		GOTO(err_llog, rc);
diff --git a/lustre/ptlrpc/import.c b/lustre/ptlrpc/import.c
index 7eaee96..9d17417 100644
--- a/lustre/ptlrpc/import.c
+++ b/lustre/ptlrpc/import.c
@@ -1263,7 +1263,7 @@ static int ptlrpc_invalidate_import_thread(void *data)
 
         ENTRY;
 
-        cfs_daemonize_ctxt("ll_imp_inval");
+	unshare_fs_struct();
 
         CDEBUG(D_HA, "thread invalidate import %s to %s@%s\n",
                imp->imp_obd->obd_name, obd2cli_tgt(imp->imp_obd),
@@ -1333,20 +1333,24 @@ int ptlrpc_import_recovery_state_machine(struct obd_import *imp)
 		spin_unlock(&imp->imp_lock);
 
 #ifdef __KERNEL__
-                /* bug 17802:  XXX client_disconnect_export vs connect request
-                 * race. if client will evicted at this time, we start
-                 * invalidate thread without reference to import and import can
-                 * be freed at same time. */
-                class_import_get(imp);
-                rc = cfs_create_thread(ptlrpc_invalidate_import_thread, imp,
-                                       CFS_DAEMON_FLAGS);
-                if (rc < 0) {
-                        class_import_put(imp);
-                        CERROR("error starting invalidate thread: %d\n", rc);
-                } else {
-                        rc = 0;
-                }
-                RETURN(rc);
+		{
+		cfs_task_t *task;
+		/* bug 17802:  XXX client_disconnect_export vs connect request
+		 * race. if client will evicted at this time, we start
+		 * invalidate thread without reference to import and import can
+		 * be freed at same time. */
+		class_import_get(imp);
+		task = kthread_run(ptlrpc_invalidate_import_thread, imp,
+				     "ll_imp_inval");
+		if (IS_ERR(task)) {
+			class_import_put(imp);
+			CERROR("error starting invalidate thread: %d\n", rc);
+			rc = PTR_ERR(task);
+		} else {
+			rc = 0;
+		}
+		RETURN(rc);
+		}
 #else
                 ptlrpc_invalidate_import(imp);
 
diff --git a/lustre/ptlrpc/pinger.c b/lustre/ptlrpc/pinger.c
index 8b7d472..e18bc7d 100644
--- a/lustre/ptlrpc/pinger.c
+++ b/lustre/ptlrpc/pinger.c
@@ -306,8 +306,6 @@ static int ptlrpc_pinger_main(void *arg)
         struct ptlrpc_thread *thread = (struct ptlrpc_thread *)arg;
 	ENTRY;
 
-        cfs_daemonize(thread->t_name);
-
         /* Record that the thread is running */
         thread_set_flags(thread, SVC_RUNNING);
         cfs_waitq_signal(&thread->t_ctl_waitq);
@@ -402,14 +400,14 @@ int ptlrpc_start_pinger(void)
 
 	/* CLONE_VM and CLONE_FILES just avoid a needless copy, because we
 	 * just drop the VM and FILES in cfs_daemonize_ctxt() right away. */
-        rc = cfs_create_thread(ptlrpc_pinger_main,
-			       pinger_thread, CFS_DAEMON_FLAGS);
-        if (rc < 0) {
-                CERROR("cannot start thread: %d\n", rc);
-                OBD_FREE(pinger_thread, sizeof(*pinger_thread));
-                pinger_thread = NULL;
-                RETURN(rc);
-        }
+	rc = PTR_ERR(kthread_run(ptlrpc_pinger_main,
+				 pinger_thread, pinger_thread->t_name));
+	if (IS_ERR_VALUE(rc)) {
+		CERROR("cannot start thread: %d\n", rc);
+		OBD_FREE(pinger_thread, sizeof(*pinger_thread));
+		pinger_thread = NULL;
+		RETURN(rc);
+	}
         l_wait_event(pinger_thread->t_ctl_waitq,
                      thread_is_running(pinger_thread), &lwi);
 
@@ -678,7 +676,7 @@ static int ping_evictor_main(void *arg)
         time_t expire_time;
         ENTRY;
 
-        cfs_daemonize_ctxt("ll_evictor");
+	unshare_fs_struct();
 
         CDEBUG(D_HA, "Starting Ping Evictor\n");
         pet_state = PET_READY;
@@ -753,18 +751,19 @@ static int ping_evictor_main(void *arg)
 
 void ping_evictor_start(void)
 {
-        int rc;
+	cfs_task_t *task;
 
-        if (++pet_refcount > 1)
-                return;
+	if (++pet_refcount > 1)
+		return;
 
-        cfs_waitq_init(&pet_waitq);
+	cfs_waitq_init(&pet_waitq);
 
-        rc = cfs_create_thread(ping_evictor_main, NULL, CFS_DAEMON_FLAGS);
-        if (rc < 0) {
-                pet_refcount--;
-                CERROR("Cannot start ping evictor thread: %d\n", rc);
-        }
+	task = kthread_run(ping_evictor_main, NULL, "ll_evictor");
+	if (IS_ERR(task)) {
+		pet_refcount--;
+		CERROR("Cannot start ping evictor thread: %ld\n",
+			PTR_ERR(task));
+	}
 }
 EXPORT_SYMBOL(ping_evictor_start);
 
diff --git a/lustre/ptlrpc/ptlrpcd.c b/lustre/ptlrpc/ptlrpcd.c
index 669b0d7..b6486e0 100644
--- a/lustre/ptlrpc/ptlrpcd.c
+++ b/lustre/ptlrpc/ptlrpcd.c
@@ -410,7 +410,7 @@ static int ptlrpcd(void *arg)
         int rc, exit = 0;
         ENTRY;
 
-	cfs_daemonize_ctxt(pc->pc_name);
+	unshare_fs_struct();
 #if defined(CONFIG_SMP) && \
 (defined(HAVE_CPUMASK_OF_NODE) || defined(HAVE_NODE_TO_CPUMASK))
 	if (test_bit(LIOD_BIND, &pc->pc_flags)) {
@@ -709,18 +709,21 @@ int ptlrpcd_start(int index, int max, const char *name, struct ptlrpcd_ctl *pc)
 
         env = 1;
 #ifdef __KERNEL__
-        if (index >= 0) {
-                rc = ptlrpcd_bind(index, max);
-                if (rc < 0)
-                        GOTO(out, rc);
-        }
+	{
+		cfs_task_t *task;
+		if (index >= 0) {
+			rc = ptlrpcd_bind(index, max);
+			if (rc < 0)
+				GOTO(out, rc);
+		}
 
-        rc = cfs_create_thread(ptlrpcd, pc, 0);
-        if (rc < 0)
-                GOTO(out, rc);
+		task = kthread_run(ptlrpcd, pc, pc->pc_name);
+		if (IS_ERR(task))
+			GOTO(out, rc = PTR_ERR(task));
 
-        rc = 0;
-	wait_for_completion(&pc->pc_starting);
+		rc = 0;
+		wait_for_completion(&pc->pc_starting);
+	}
 #else
         pc->pc_wait_callback =
                 liblustre_register_wait_callback("ptlrpcd_check_async_rpcs",
diff --git a/lustre/ptlrpc/sec_gc.c b/lustre/ptlrpc/sec_gc.c
index 7634d22..595f710 100644
--- a/lustre/ptlrpc/sec_gc.c
+++ b/lustre/ptlrpc/sec_gc.c
@@ -169,7 +169,7 @@ static int sec_gc_main(void *arg)
         struct ptlrpc_thread *thread = (struct ptlrpc_thread *) arg;
         struct l_wait_info    lwi;
 
-        cfs_daemonize_ctxt("sptlrpc_gc");
+	unshare_fs_struct();
 
         /* Record that the thread is running */
         thread_set_flags(thread, SVC_RUNNING);
@@ -222,7 +222,7 @@ again:
 int sptlrpc_gc_init(void)
 {
 	struct l_wait_info lwi = { 0 };
-	int                rc;
+	cfs_task_t *task;
 
 	mutex_init(&sec_gc_mutex);
 	spin_lock_init(&sec_gc_list_lock);
@@ -232,10 +232,10 @@ int sptlrpc_gc_init(void)
         memset(&sec_gc_thread, 0, sizeof(sec_gc_thread));
         cfs_waitq_init(&sec_gc_thread.t_ctl_waitq);
 
-        rc = cfs_create_thread(sec_gc_main, &sec_gc_thread, CFS_DAEMON_FLAGS);
-        if (rc < 0) {
-                CERROR("can't start gc thread: %d\n", rc);
-                return rc;
+	task = kthread_run(sec_gc_main, &sec_gc_thread, "sptlrpc_gc");
+	if (IS_ERR(task)) {
+		CERROR("can't start gc thread: %ld\n", PTR_ERR(task));
+		return PTR_ERR(task);
         }
 
         l_wait_event(sec_gc_thread.t_ctl_waitq,
diff --git a/lustre/ptlrpc/service.c b/lustre/ptlrpc/service.c
index 63fee6d..7d73b13 100644
--- a/lustre/ptlrpc/service.c
+++ b/lustre/ptlrpc/service.c
@@ -2362,7 +2362,7 @@ static int ptlrpc_main(void *arg)
         ENTRY;
 
         thread->t_pid = cfs_curproc_pid();
-        cfs_daemonize_ctxt(thread->t_name);
+	unshare_fs_struct();
 
 	/* NB: we will call cfs_cpt_bind() for all threads, because we
 	 * might want to run lustre server only on a subset of system CPUs,
@@ -2557,7 +2557,7 @@ static int ptlrpc_hr_main(void *arg)
 
 	snprintf(threadname, sizeof(threadname), "ptlrpc_hr%02d_%03d",
 		 hrp->hrp_cpt, hrt->hrt_id);
-	cfs_daemonize_ctxt(threadname);
+	unshare_fs_struct();
 
 	rc = cfs_cpt_bind(ptlrpc_hr.hr_cpt_table, hrp->hrp_cpt);
 	if (rc != 0) {
@@ -2623,10 +2623,13 @@ static int ptlrpc_start_hr_threads(void)
 		int	rc = 0;
 
 		for (j = 0; j < hrp->hrp_nthrs; j++) {
-			rc = cfs_create_thread(ptlrpc_hr_main,
-					       &hrp->hrp_thrs[j],
-					       CLONE_VM | CLONE_FILES);
-			if (rc < 0)
+			struct	ptlrpc_hr_thread *hrt = &hrp->hrp_thrs[j];
+			rc = PTR_ERR(kthread_run(ptlrpc_hr_main,
+						 &hrp->hrp_thrs[j],
+						 "ptlrpc_hr%02d_%03d",
+						 hrp->hrp_cpt,
+						 hrt->hrt_id));
+			if (IS_ERR_VALUE(rc))
 				break;
 		}
 		cfs_wait_event(ptlrpc_hr.hr_waitq,
@@ -2818,8 +2821,8 @@ int ptlrpc_start_thread(struct ptlrpc_service_part *svcpt, int wait)
 	 * CLONE_VM and CLONE_FILES just avoid a needless copy, because we
 	 * just drop the VM and FILES in cfs_daemonize_ctxt() right away.
 	 */
-	rc = cfs_create_thread(ptlrpc_main, thread, CFS_DAEMON_FLAGS);
-	if (rc < 0) {
+	rc = PTR_ERR(kthread_run(ptlrpc_main, thread, thread->t_name));
+	if (IS_ERR_VALUE(rc)) {
 		CERROR("cannot start thread '%s': rc %d\n",
 		       thread->t_name, rc);
 		spin_lock(&svcpt->scp_lock);
diff --git a/lustre/quota/qmt_lock.c b/lustre/quota/qmt_lock.c
index 3236fb5..7c455fe 100644
--- a/lustre/quota/qmt_lock.c
+++ b/lustre/quota/qmt_lock.c
@@ -716,7 +716,6 @@ static int qmt_reba_thread(void *arg)
 	struct l_wait_info	 lwi = { 0 };
 	struct lu_env		*env;
 	struct lquota_entry	*lqe, *tmp;
-	char			 pname[MTI_NAME_MAXLEN];
 	int			 rc;
 	ENTRY;
 
@@ -731,9 +730,6 @@ static int qmt_reba_thread(void *arg)
 		RETURN(rc);
 	}
 
-	snprintf(pname, MTI_NAME_MAXLEN, "qmt_reba_%s", qmt->qmt_svname);
-	cfs_daemonize(pname);
-
 	thread_set_flags(thread, SVC_RUNNING);
 	cfs_waitq_signal(&thread->t_ctl_waitq);
 
@@ -773,15 +769,16 @@ int qmt_start_reba_thread(struct qmt_device *qmt)
 {
 	struct ptlrpc_thread	*thread = &qmt->qmt_reba_thread;
 	struct l_wait_info	 lwi    = { 0 };
-	int			 rc;
+	cfs_task_t		*task;
 	ENTRY;
 
-	rc = cfs_create_thread(qmt_reba_thread, (void *)qmt, 0);
-	if (rc < 0) {
-		CERROR("%s: failed to start rebalance thread (%d)\n",
-		       qmt->qmt_svname, rc);
+	task = kthread_run(qmt_reba_thread, (void *)qmt,
+			       "qmt_reba_%s", qmt->qmt_svname);
+	if (IS_ERR(task)) {
+		CERROR("%s: failed to start rebalance thread (%ld)\n",
+		       qmt->qmt_svname, PTR_ERR(task));
 		thread_set_flags(thread, SVC_STOPPED);
-		RETURN(rc);
+		RETURN(PTR_ERR(task));
 	}
 
 	l_wait_event(thread->t_ctl_waitq,
diff --git a/lustre/quota/qsd_reint.c b/lustre/quota/qsd_reint.c
index ad2894f..070e535 100644
--- a/lustre/quota/qsd_reint.c
+++ b/lustre/quota/qsd_reint.c
@@ -417,8 +417,6 @@ static int qsd_reint_main(void *args)
 	int			 rc;
 	ENTRY;
 
-	cfs_daemonize("qsd_reint");
-
 	CDEBUG(D_QUOTA, "%s: Starting reintegration thread for "DFID"\n",
 	       qsd->qsd_svname, PFID(&qqi->qqi_fid));
 
@@ -662,8 +660,8 @@ int qsd_start_reint_thread(struct qsd_qtype_info *qqi)
 		RETURN(0);
 	}
 
-	rc = cfs_create_thread(qsd_reint_main, (void *)qqi, 0);
-	if (rc < 0) {
+	rc = PTR_ERR(kthread_run(qsd_reint_main, (void *)qqi, "qsd_reint"));
+	if (IS_ERR_VALUE(rc)) {
 		thread_set_flags(thread, SVC_STOPPED);
 		write_lock(&qsd->qsd_lock);
 		qqi->qqi_reint = 0;
diff --git a/lustre/quota/qsd_writeback.c b/lustre/quota/qsd_writeback.c
index 037fb2b..5ab39e4 100644
--- a/lustre/quota/qsd_writeback.c
+++ b/lustre/quota/qsd_writeback.c
@@ -404,7 +404,6 @@ static int qsd_upd_thread(void *arg)
 	struct l_wait_info	 lwi;
 	cfs_list_t		 queue;
 	struct qsd_upd_rec	*upd, *n;
-	char			 pname[MTI_NAME_MAXLEN];
 	struct lu_env		*env;
 	int			 qtype, rc = 0;
 	bool			 uptodate;
@@ -423,9 +422,6 @@ static int qsd_upd_thread(void *arg)
 		RETURN(rc);
 	}
 
-	snprintf(pname, MTI_NAME_MAXLEN, "lquota_wb_%s", qsd->qsd_svname);
-	cfs_daemonize(pname);
-
 	thread_set_flags(thread, SVC_RUNNING);
 	cfs_waitq_signal(&thread->t_ctl_waitq);
 
@@ -487,14 +483,16 @@ int qsd_start_upd_thread(struct qsd_instance *qsd)
 {
 	struct ptlrpc_thread	*thread = &qsd->qsd_upd_thread;
 	struct l_wait_info	 lwi = { 0 };
-	int			 rc;
+	cfs_task_t		*task;
 	ENTRY;
 
-	rc = cfs_create_thread(qsd_upd_thread, (void *)qsd, 0);
-	if (rc < 0) {
-		CERROR("Fail to start quota update thread. rc: %d\n", rc);
+	task = kthread_run(qsd_upd_thread, (void *)qsd,
+			   "lquota_wb_%s", qsd->qsd_svname);
+	if (IS_ERR(task)) {
+		CERROR("Fail to start quota update thread. rc: %ld\n",
+			PTR_ERR(task));
 		thread_set_flags(thread, SVC_STOPPED);
-		RETURN(rc);
+		RETURN(PTR_ERR(task));
 	}
 
 	l_wait_event(thread->t_ctl_waitq,
-- 
1.8.1.5

